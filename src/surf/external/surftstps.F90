SUBROUTINE SURFTSTPS (YDSURF, KIDIA, KFDIA, KLON, KLEVS, KLEVSN, KTILES,&
 & PSSDP2, PSSDP3,&
 & PTSPHY , PSDOR, PFRTI,&
 & PCIL, &
 & PAHFSTI, PEVAPTI, PSSRFLTI,&
 & LDLAND,  LDSICE, LDSI, LDNH,&
 & PSNM1M  ,PTSNM1M,PRSNM1M,&
 & PTSAM1M, PTIAM1M,&
 & PWLM1M  ,PWSAM1M,&
 & PHLICEM1M, PAPRS, &
 & PRSFC   ,PRSFL,&
 & PSLRFL  ,PSSFC  ,PSSFL,&
 & PCVL    ,PCVH   ,PCUR  ,PWLMX   ,PEVAPSNW,&
 & LNEMOICETHK, PTHKICE, &
!-TENDENCIES OUTPUT
 & PTSNE1 , PTSAE1 , PTIAE1)

USE PARKIND1, ONLY : JPIM, JPRB
USE ISO_C_BINDING

!ifndef INTERFACE

USE YOMHOOK,  ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOS_SURF, ONLY : TSURF, GET_SURF

USE ABORT_SURF_MOD
USE SURFTSTPS_CTL_MOD
!endif INTERFACE

! (C) Copyright 2011- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

!     ------------------------------------------------------------------
!**** *SURFTSTPS* - UPDATES LAND VALUES OF TEMPERATURE AND SNOW.

!     PURPOSE.
!     --------
!          This routine updates the sea ice values of temperature
!     and the land values of soil temperature and snow temperature. 
!     For temperature, this is done via a forward time
!     step damped with some implicit linear considerations: as if all
!     fluxes that explicitely depend on the variable had only a linear
!     variation around the t-1 value. 

!**   INTERFACE.
!     ----------
!          *SURFTSTPS* IS CALLED FROM *CALLPAR*.
!          THE ROUTINE TAKES ITS INPUT FROM THE LONG-TERM STORAGE:
!     TSA,WL,SN AT T-1,TSK,SURFACE FLUXES COMPUTED IN OTHER PARTS OF
!     THE PHYSICS, AND W AND LAND-SEA MASK. IT RETURNS AS AN OUTPUT
!     TENDENCIES TO THE SAME VARIABLES (TSA,WL,SN).

!     PARAMETER   DESCRIPTION                                    UNITS
!     ---------   -----------                                    -----
!     INPUT PARAMETERS (INTEGER):
!    *KIDIA*      START POINT
!    *KFDIA*      END POINT
!    *KLEV*       NUMBER OF LEVELS
!    *KLON*       NUMBER OF GRID POINTS PER PACKET
!    *KLEVS*      NUMBER OF SOIL LAYERS
!    *KTILES*     NUMBER OF TILES (I.E. SUBGRID AREAS WITH DIFFERENT
!                 SURFACE BOUNDARY CONDITION)

!     INPUT PARAMETERS (REAL):
!    *PTSPHY*     TIME STEP FOR THE PHYSICS                      S
!    *PFRTI*      TILE FRACTIONS                              (0-1)
!            1 : WATER                  5 : SNOW ON LOW-VEG+BARE-SOIL
!            2 : ICE                    6 : DRY SNOW-FREE HIGH-VEG
!            3 : WET SKIN               7 : SNOW UNDER HIGH-VEG
!            4 : DRY SNOW-FREE LOW-VEG  8 : BARE SOIL
!    *PAHFSTI*      SURFACE SENSIBLE HEAT FLUX, FOR EACH TILE  W/M2
!    *PEVAPTI*      SURFACE MOISTURE FLUX, FOR EACH TILE      KG/M2/S
!    *PSSRFLTI*     NET SHORTWAVE RADIATION FLUX AT SURFACE, FOR
!                       EACH TILE                                 W/M2

!     INPUT PARAMETERS (LOGICAL):
!    *LDLAND*     LAND/SEA MASK (TRUE/FALSE)
!    *LDSICE*     SEA ICE MASK (.T. OVER SEA ICE)
!    *LDSI*       TRUE IF THERMALLY RESPONSIVE SEA-ICE
!    *LDNH*       TRUE FOR NORTHERN HEMISPHERE LATITUDE ROW

!     INPUT PARAMETERS AT T-1 OR CONSTANT IN TIME (REAL):
!    *PSNM1M*     SNOW MASS (per unit area)                      KG/M**2
!    *PRSNM1M*    SNOW DENSITY                                   KG/M3
!    *PTSNM1M*    SNOW TEMPERATURE                               K
!    *PTSAM1M*    SOIL TEMPERATURE                               K
!    *PTIAM1M*    SEA-ICE TEMPERATURE                            K
!          (NB: REPRESENTS THE FRACTION OF ICE ONLY, NOT THE GRID-BOX)
!    *PWLM1M*     SKIN RESERVOIR WATER CONTENT                   kg/m**2
!    *PWSAM1M*    SOIL MOISTURE                                m**3/m**3
!    *PHLICEM1M*  LAKE ICE THICKNESS                             m
!    *PRSFC*      CONVECTIVE RAIN FLUX AT THE SURFACE          KG/M**2/S
!    *PRSFL*      LARGE SCALE RAIN FLUX AT THE SURFACE         KG/M**2/S
!    *PSLRFL*     NET LONGWAVE  RADIATION AT THE SURFACE         W/M**2
!    *PSSFC*      CONVECTIVE  SNOW FLUX AT THE SURFACE         KG/M**2/S
!    *PSSFL*      LARGE SCALE SNOW FLUX AT THE SURFACE         KG/M**2/S
!    *PCVL*       LOW VEGETATION COVER  (CORRECTED)              (0-1)
!    *PCVH*       HIGH VEGETATION COVER (CORRECTED)              (0-1)
!    *PCUR*       URBAN COVER (PASSIVE)                          (0-1)
!    *PWLMX*      MAXIMUM SKIN RESERVOIR CAPACITY                kg/m**2
!    *PEVAPSNW*   EVAPORATION FROM SNOW UNDER FOREST           KG/M**2/S


!     OUTPUT PARAMETERS (TENDENCIES):
!    *PTSNE1*     SNOW TEMPERATURE                              K/S
!    *PTSAE1*     SOIL TEMPERATURE TENDENCY                     K/S
!    *PTIAE1*     SEA-ICE TEMPERATURE TENDENCY                  K/S

!     METHOD.
!     -------
!          STRAIGHTFORWARD ONCE THE DEFINITION OF THE CONSTANTS IS
!     UNDERSTOOD. FOR THIS REFER TO DOCUMENTATION. FOR THE TIME FILTER
!     SEE CORRESPONDING PART OF THE DOCUMENTATION OF THE ADIABATIC CODE.

!     EXTERNALS.
!     ----------
!          *SRFWLS*        COMPUTES THE SKIN RESERVOIR CHANGES.
!          *SRFSN_LWIMPS*  REVISED SNOW SCHEME W. DIAG. LIQ. WATER.
!          *SRFRCGS*       COMPUTE SOIL HEAT CAPACITY.
!          *SRFTS*         COMPUTES THE TEMPERATURE CHANGES BEFORE THE SNOW
!                            MELTING.
!          *SRFIS*         COMPUTES TEMPERATURE EVOLUTION OF SEA ICE.

!     REFERENCE.
!     ----------
!          SEE SOIL PROCESSES' PART OF THE MODEL'S DOCUMENTATION FOR
!     DETAILS ABOUT THE MATHEMATICS OF THIS ROUTINE.

!     ------------------------------------------------------------------

!     Original   
!     --------
!          Simplified version based on SURFTSTP:
!     M. Janiskova              E.C.M.W.F.     27-07-2011

!     Modifications
!     -------------

!     ------------------------------------------------------------------

IMPLICIT NONE

! Declaration of arguments

TYPE(C_PTR)       ,INTENT(IN)    :: YDSURF
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSDP2(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSDP3(:,:,:)
INTEGER(KIND=JPIM),INTENT(IN)    :: KIDIA
INTEGER(KIND=JPIM),INTENT(IN)    :: KFDIA
INTEGER(KIND=JPIM),INTENT(IN)    :: KLON
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVS
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVSN
INTEGER(KIND=JPIM),INTENT(IN)    :: KTILES
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAHFSTI(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PEVAPTI(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSRFLTI(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSPHY
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSDOR(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCIL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PFRTI(:,:)
LOGICAL           ,INTENT(IN)    :: LDLAND(:)
LOGICAL           ,INTENT(IN)    :: LDSICE(:)
LOGICAL           ,INTENT(IN)    :: LDSI
LOGICAL           ,INTENT(IN)    :: LDNH(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSNM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSNM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSNM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSAM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTIAM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWLM1M(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWSAM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSFC(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSFL(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSLRFL(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSFC(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSFL(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCVL(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCVH(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCUR(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWLMX(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PEVAPSNW(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PHLICEM1M(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAPRS(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSNE1(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSAE1(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTIAE1(:,:)
LOGICAL           ,INTENT(IN)    :: LNEMOICETHK
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTHKICE(:)

!ifndef INTERFACE

TYPE(TSURF), POINTER :: YSURF
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SURFTSTPS',0,ZHOOK_HANDLE)

YSURF => GET_SURF(YDSURF)

IF(UBOUND(PSDOR,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSDOR TOO SHORT!')
ENDIF

IF(UBOUND(PCIL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PCIL TOO SHORT!')
ENDIF

IF(UBOUND(PSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PRSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PWLM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWLM1M TOO SHORT!')
ENDIF

IF(UBOUND(PHLICEM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PHLICEM1M TOO SHORT!')
ENDIF

IF(UBOUND(PRSFC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSFC TOO SHORT!')
ENDIF

IF(UBOUND(PRSFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSFL TOO SHORT!')
ENDIF

IF(UBOUND(PSLRFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSLRFL TOO SHORT!')
ENDIF

IF(UBOUND(PSSFC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSSFC TOO SHORT!')
ENDIF

IF(UBOUND(PSSFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSSFL TOO SHORT!')
ENDIF

IF(UBOUND(PCVL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCVL TOO SHORT!')
ENDIF

IF(UBOUND(PCVH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCVH TOO SHORT!')
ENDIF

IF(UBOUND(PCUR,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCUR TOO SHORT!')
ENDIF

IF(UBOUND(PWLMX,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWLMX TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPSNW,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PEVAPSNW TOO SHORT!')
ENDIF

IF(UBOUND(LDLAND,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDLAND TOO SHORT!')
ENDIF

IF(UBOUND(LDSICE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDSICE TOO SHORT!')
ENDIF

IF(UBOUND(LDNH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDNH TOO SHORT!')
ENDIF

IF(UBOUND(PTSNE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTSNE1 TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFLTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSSRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFLTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PSSRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTIAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTIAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTIAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTIAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PWSAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PWSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTHKICE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTHKICE TOO SHORT!')
ENDIF

IF(UBOUND(PWSAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PWSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSAE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTSAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTSAE1,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTSAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTIAE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTIAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTIAE1,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTIAE1 TOO SHORT!')
ENDIF


CALL SURFTSTPS_CTL(KIDIA, KFDIA, KLON, KLEVS, KLEVSN, KTILES,&
 & PTSPHY , PSDOR, PFRTI,&
 & PCIL, &
 & PAHFSTI, PEVAPTI, PSSRFLTI,&
 & LDLAND,  LDSICE, LDSI, LDNH,&
 & PSNM1M  ,PTSNM1M,PRSNM1M,&
 & PTSAM1M, PTIAM1M,&
 & PWLM1M  ,PWSAM1M,&
 & PHLICEM1M, PAPRS,&
 & PRSFC   ,PRSFL,&
 & PSLRFL  ,PSSFC  ,PSSFL,&
 & PCVL    ,PCVH   ,PWLMX   ,PEVAPSNW,&
 & PSSDP2  ,PSSDP3,&
 & LNEMOICETHK, PTHKICE,&
 & YSURF%YCST,YSURF%YVEG,YSURF%YSOIL,YSURF%YFLAKE,YSURF%YURB,&
!-TENDENCIES OUTPUT
 & PTSNE1 , PTSAE1 , PTIAE1)


!-END OF CALL SURFTSTPS

IF (LHOOK) CALL DR_HOOK('SURFTSTPS',1,ZHOOK_HANDLE)

!endif INTERFACE

!     ------------------------------------------------------------------

END SUBROUTINE SURFTSTPS
