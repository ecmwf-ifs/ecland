SUBROUTINE SURFEXCDRIVER    (YDSURF, CDCONF &
 & , KIDIA, KFDIA, KLON, KLEVS, KTILES, KVTYPES, KDIAG, KSTEP &
 & , KLEVSN, KLEVI,LDLAND, KDHVTLS, KDHFTLS, KDHVTSS, KDHFTSS &
 & , KDHVTTS, KDHFTTS, KDHVTIS, KDHFTIS, K_VMASS &
 & , KDHVCO2S,KDHFCO2S,KDHVBVOCS,KDHVVEGS,KDHFVEGS &
 & , PTSTEP,PTSTEPF &
 & , PPPFD_TOA &
! input data, non-tiled
 & , KTVL, KCO2TYP, KTVH, PCVL, PCVH, PCUR &
 & , PLAIL, PLAIH &
 & , PLAILP, PLAIHP, PAVGPAR, PISOP_EP &
 & , PFWET, PLAT &
 & , PSNM , PRSN &
 & , PMU0 , PCARDI &
 & , PUMLEV, PVMLEV, PTMLEV, PQMLEV, PCMLEV, PAPHMS, PGEOMLEV, PCPTGZLEV &
 & , PSST, PTSKM1M, PCHAR, PCHARHQ, PSSRFL, PSLRFL, PEMIS, PTICE, PTSN &
 & , PHLICE,PTLICE,PTLWML & 
 & , PTHKICE,PSNTICE &
 & , PWLMX, PUCURR, PVCURR, PI10FGCV &
 & , PSSDP2, PSSDP3 &
! input data, soil
 & , PTSAM1M, PWSAM1M, KSOTY &
! input data, tiled
 & , PFRTI, PALBTI &
! updated data, tiled
 & , PUSTRTI, PVSTRTI, PAHFSTI, PEVAPTI, PTSKTI &
 & , PANDAYVT,PANFMVT &
! updated data, non-tiled
 & , PZ0M, PZ0H &
! output data, tiled
 & , PSSRFLTI, PQSTI, PDQSTI, PCPTSTI, PCFHTI, PCFQTI, PCSATTI, PCAIRTI &
 & , PCPTSTIU, PCSATTIU, PCAIRTIU,PRAQTI,PTSRF,PLAMSK &
 & , PZ0MTIW, PZ0HTIW, PZ0QTIW, PZDLTI, PQSAPPTI, PCPTSPPTI &
! output data, non-tiled
 & , PKHLEV, PKCLEV, PCFMLEV, PKMFL, PKHFL, PKQFL, PEVAPSNW &
 & , PZ0MW, PZ0HW, PZ0QW, PBLENDPP, PCPTSPP, PQSAPP, PBUOMPP, PZDLPP &
! output data, non-tiled CO2
 & , PAN,PAG,PRD,PRSOIL_STR,PRECO,PCO2FLUX,PCH4FLUX&
! output data: Biogenic VOC (BVOC) emissions
 & , PBVOCFLUX &
! output canopy and bare soild resistance 
 & , PWETB, PWETL, PWETLU, PWETH, PWETHS &
! output data, diagnostics
 & , PDHTLS, PDHTSS, PDHTTS, PDHTIS &
 & , PDHVEGS, PEXDIAG, PDHCO2S,PDHBVOCS &
 & , PRPLRG &
 & , LSICOUP, LDSICE, LBLEND &
 & )

USE PARKIND1, ONLY : JPIM, JPRB, JPRD
USE ISO_C_BINDING

!ifndef INTERFACE

USE YOMHOOK, ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOS_SURF, ONLY : TSURF, GET_SURF

USE ABORT_SURF_MOD
USE SURFEXCDRIVER_CTL_MOD

!endif INTERFACE
! (C) Copyright 2005- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!------------------------------------------------------------------------

!  PURPOSE:
!    Routine SURFEXCDRIVER controls the ensemble of routines that prepare
!    the surface exchange coefficients and associated surface quantities
!    needed for the solution of the vertical diffusion equations. 

!  SURFEXCDRIVER is called by VDFMAIN

!  METHOD:
!    This routine is only a shell needed by the surface library
!    externalisation.

!  AUTHOR:
!    P. Viterbo       ECMWF May 2005   

!  REVISION HISTORY:
!    E. Dutra/G. Balsamo May 2008 Add lake tile
!    S. Boussetta/G.Balsamo May 2009 Add lai
!    S. Boussetta/G.Balsamo May 2010 Add CTESSEL
!    N. Semane  04-10-2012  Include small planet PRPLRG
!    Linus Magnusson     10-09-28 Sea-ice

!  INTERFACE: 

!    Characters (In):
!      CDCONF   :    IFS Configuration

!    Integers (In):
!      KIDIA    :    Begin point in arrays
!      KFDIA    :    End point in arrays
!      KLON     :    Length of arrays
!      KLEVS    :    Number of soil layers
!      KTILES   :    Number of tiles
!      KVTYPES  :    Number of biomes for carbon
!      KDIAG    :    Number of diagnostic parameters
!      KSTEP    :    Time step index
!      KLEVSN   :    Number of snow layers (diagnostics) 
!      KLEVI    :    Number of sea ice layers (diagnostics)
!      KDHVTLS  :    Number of variables for individual tiles
!      KDHFTLS  :    Number of fluxes for individual tiles
!      KDHVTSS  :    Number of variables for snow energy budget
!      KDHFTSS  :    Number of fluxes for snow energy budget
!      KDHVTTS  :    Number of variables for soil energy budget
!      KDHFTTS  :    Number of fluxes for soil energy budget
!      KDHVTIS  :    Number of variables for sea ice energy budget
!      KDHFTIS  :    Number of fluxes for sea ice energy budget
!      K_VMASS  :    Controls the use of vector functions in the IBM scientific
!                     library. Set K_VMASS=0 to use standard functions
!      KTVL     :    Dominant low vegetation type
!      KCO2TYP :    Type of photosynthetic pathway for low vegetation (c3/c4)
!      KTVH     :    Dominant high vegetation type
!      KSOTY    :    SOIL TYPE                                        (1-7)
!      LBLEND   :    Option to make blending heigh function of z0m (Logical)

!    *KDHVCO2S*     Number of variables for CO2
!    *KDHFCO2S*     Number of fluxes for CO2
!    *KDHVBVOCS*    Number of variables for BVOC
!    *KDHVVEGS*     Number of variables for vegetation
!    *KDHFVEGS*     Number of fluxes for vegetation


!    Reals (In):
!      PTSTEP   :    Timestep
!      PCVL     :    Low vegetation fraction
!      PCVH     :    High vegetation fraction
!      PCUR     :    Urban cover                                      (0-1)
!      PLAIL    :    Low vegetation LAI
!      PLAIH    :    High vegetation LAI
!      PLAILP   :    Low vegetation LAI previous time step
!      PLAIHP   :    High vegetation LAI previous time step
!      PAVGPAR  :    Average PAR
!      PISOP_EP :    Isoprene Emission Potential 

!     PSNM      :       SNOW MASS (per unit area)                      kg/m**2
!     PRSN      :      SNOW DENSITY                                   kg/m**3

!      PMU0          : COS SOLAR angle
!      PCARDI        : CONCENTRATION ATMOSPHERIC CO2
!      PRPLRG    :   ! GRAVITY SMALL PLANET FACTOR 

!    Reals with tile index (In): 
!      PFRTI    :    TILE FRACTIONS                                   (0-1)
!            1 : WATER                  5 : SNOW ON LOW-VEG+BARE-SOIL
!            2 : ICE                    6 : DRY SNOW-FREE HIGH-VEG
!            3 : WET SKIN               7 : SNOW UNDER HIGH-VEG
!            4 : DRY SNOW-FREE LOW-VEG  8 : BARE SOIL
!      PALBTI   :    Tile albedo                                      (0-1)

!    Reals independent of tiles (In):
!      PUMLEV   :    X-VELOCITY COMPONENT, lowest atmospheric level   m/s
!      PVMLEV   :    Y-VELOCITY COMPONENT, lowest atmospheric level   m/s
!      PTMLEV   :    TEMPERATURE,   lowest atmospheric level          K
!      PQMLEV   :    SPECIFIC HUMIDITY                                kg/kg
!      PCMLEV   :    ATMOSPHERIC CO2                                  kg/kg
!      PAPHMS   :    Surface pressure                                 Pa
!      PGEOMLEV :    Geopotential, lowest atmospehric level           m2/s2
!      PCPTGZLEV:    Geopotential, lowest atmospehric level           J/kg
!      PSST     :    (OPEN) SEA SURFACE TEMPERATURE                   K
!      PTSKM1M  :    SKIN TEMPERATURE                                 K
!      PCHAR    :    CHARNOCK PARAMETER                               -
!      PCHARHQ  :    CHARNOCK PARAMETER FOR HEAT AND MOISTURE         -
!      PSSRFL   :    NET SHORTWAVE RADIATION FLUX AT SURFACE          W/m2
!      PSLRFL   :    NET LONGWAVE RADIATION FLUX AT SURFACE           W/m2
!      PEMIS    :    MODEL SURFACE LONGWAVE EMISSIVITY
!      PTSAM1M  :    SURFACE TEMPERATURE                              K
!      PWSAM1M  :    SOIL MOISTURE ALL LAYERS                         m**3/m**3
!      PTICE    :    Ice temperature, top slab                        K
!      PTSN     :    Snow temperature                                 K
!      PHLICE   :    Lake ice thickness                               m
!      PTLICE   :    Lake ice temperature                             K
!      PTLWML   :    Lake mean water temperature                      K
!      PTHKICE  :    Sea-ice thickness                                m
!      PSNTICE  :    Snow thickness on sea-ice                        m
!      PWLMX    :    Maximum interception layer capacity              kg/m**2
!      PUCURR   :    u component of ocean surface current             m/s
!      PVCURR   :    v component of ocean surface current             m/s
!      PI10FGCV :    gust velocity from deep convection               m/s
!    Logicals independent of tiles (In):
!     LDLAND    :    LAND SEA MASK INDICATOR                       -

!    Reals with tile index (In/Out):
!      PUSTRTI  :    SURFACE U-STRESS                                 N/m2 
!      PVSTRTI  :    SURFACE V-STRESS                                 N/m2
!      PAHFSTI  :    SURFACE SENSIBLE HEAT FLUX                       W/m2
!      PEVAPTI  :    SURFACE MOISTURE FLUX                            KG/m2/s
!      PTSKTI   :    SKIN TEMPERATURE                                 K

!    	UPDATED PARAMETERS FOR VEGETATION TYPES (REAL):
!      PANDAYVT :    DAILY NET CO2 ASSIMILATION OVER CANOPY           kg_CO2/m**2
!      PANFMVT  :    MAXIMUM LEAF ASSIMILATION                        kg_CO2/kg_Air m/s

!    Reals independent of tiles (In/Out):
!      PZ0M     :    AERODYNAMIC ROUGHNESS LENGTH                     m
!      PZ0H     :    ROUGHNESS LENGTH FOR HEAT                        m

!    Reals with tile index (Out):
!      PSSRFLTI :    Tiled NET SHORTWAVE RADIATION FLUX AT SURFACE    W/m2
!      PQSTI    :    Tiled SATURATION Q AT SURFACE                    kg/kg
!      PDQSTI   :    Tiled DERIVATIVE OF SATURATION Q-CURVE           kg/kg/K
!      PCPTSTI  :    Tiled DRY STATIC ENERGY AT SURFACE               J/kg
!      PCFHTI   :    Tiled EXCHANGE COEFFICIENT AT THE SURFACE        ????
!      PCFQTI   :    Tiled EXCHANGE COEFFICIENT AT THE SURFACE        ????
!      PCSATTI  :    MULTIPLICATION FACTOR FOR QS AT SURFACE          -
!                      FOR SURFACE FLUX COMPUTATION
!      PCAIRTI  :    MULTIPLICATION FACTOR FOR Q AT  LOWEST MODEL     - 
!                      LEVEL FOR SURFACE FLUX COMPUTATION
!      PCPTSTIU :    AS PCPTSTI FOR UNSTRESSED LOW VEGETATION         J/kg
!      PCSATTIU :    AS PCSATTI FOR UNSTRESSED LOW VEGETATION         -
!      PCAIRTIU :    AS PCAIRTI FOR UNSTRESSED LOW VEGETATION         - 
!      PRAQTI   :    Aerodynamic resistance                           - 
!      PTSRF    :    Tiled surface temperature for each tile 
!                    Boundary condition in surfseb                    K
!      PLAMSK   :    Tiled skin layer conductivity                    W m-2 K-1

!    Reals independent of tiles (Out):
!      PKHLEV   :    SURFACE LAYER: CH*U                              m/s
!      PKCLEV   :    SURFACE LAYER: Cc*U  tracer transfer             m/s
!      PCFMLEV  :    PROP. TO EXCH. COEFF. FOR MOMENTUM               ????
!                     (C-STAR IN DOC.) (SURFACE LAYER ONLY)
!      PKMFL    :    Kinematic momentum flux                          ????
!      PKHFL    :    Kinematic heat flux                              ????
!      PKQFL    :    Kinematic moisture flux                          ????
!      PEVAPSNW :    Evaporation from snow under forest               kgm-2s-1
!      PZ0MW    :    Roughness length for momentum, WMO station       m
!      PZ0HW    :    Roughness length for heat, WMO station           m
!      PZ0QW    :    Roughness length for moisture, WMO station       m
!      PBLENDPP :    Blending weight for 10 m wind postprocessing     m
!      PCPTSPP  :    Cp*Ts for post-processing of weather parameters  J/kg
!      PQSAPP   :    Apparent surface humidity for post-processing    kg/kg
!                     of weather parameters
!      PBUOMPP  :    Buoyancy flux, for post-processing of gustiness  ???? 
!      PZDLPP   :    z/L for post-processing of weather parameters    -
!      PDHTLS   :    Diagnostic array for tiles (see module yomcdh)
!                      (Wm-2 for energy fluxes, kg/(m2s) for water fluxes)
!      PDHTSS   :    Diagnostic array for snow T (see module yomcdh)
!                      (Wm-2 for fluxes)
!      PDHTTS   :    Diagnostic array for soil T (see module yomcdh)
!                      (Wm-2 for fluxes)
!      PDHTIS   :    Diagnostic array for ice T (see module yomcdh)
!                      (Wm-2 for fluxes)

!     *PDHVEGS*      Diagnostic array for vegetation (see module yomcdh) 
!     *PEXDIAG*      Diagnostic array for optional pp of canopy resistances
!     *PDHCO2S*      Diagnostic array for CO2 (see module yomcdh)
!     *PDHBVOCS*     Diagnostic array for BVOC (see module yomcdh)
!       PWETB        Surface resistance bare soild 
!       PWETL        Canopy resistance of low vegetation  
!       PWETLU       Canopy resistance of low vegetation , unstressed 
!       PWETH        Canopy resistance of high vegetation  
!       PWETHS       Canopy resistance of high vegetation snow cover  

!     EXTERNALS.
!     ----------

!     ** SURFEXCDRIVER_CTL CALLS SUCCESSIVELY:
!         *VUPDZ0*
!         *VSURF*
!         *CO2* 
!         *VEXCS*
!         *VEVAP*
!         *VSFLX*

!  DOCUMENTATION:
!    See Physics Volume of IFS documentation

!------------------------------------------------------------------------

IMPLICIT NONE

! Declaration of arguments

TYPE(C_PTR),                  INTENT(IN)  :: YDSURF

CHARACTER(LEN=1)  ,INTENT(IN)    :: CDCONF 

INTEGER(KIND=JPIM),INTENT(IN)    :: KIDIA
INTEGER(KIND=JPIM),INTENT(IN)    :: KFDIA
INTEGER(KIND=JPIM),INTENT(IN)    :: KLON
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVS
INTEGER(KIND=JPIM),INTENT(IN)    :: KTILES
INTEGER(KIND=JPIM),INTENT(IN)    :: KVTYPES
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIAG
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTEP
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVSN 
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVI 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTLS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTLS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTSS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTSS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTTS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTTS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTIS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTIS 
INTEGER(KIND=JPIM),INTENT(IN)    :: K_VMASS
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSTEP
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSTEPF
REAL(KIND=JPRB)   ,INTENT(IN)    :: PPPFD_TOA
LOGICAL,INTENT(IN)               :: LDLAND(:)
INTEGER(KIND=JPIM),INTENT(IN)    :: KTVL(:) 
INTEGER(KIND=JPIM),INTENT(IN)    :: KCO2TYP(:) 
INTEGER(KIND=JPIM),INTENT(IN)    :: KTVH(:) 
INTEGER(KIND=JPIM),INTENT(IN)    :: KSOTY(:)
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVCO2S
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFCO2S
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVBVOCS
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVVEGS
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFVEGS
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCVL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCVH(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCUR(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAIL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAIH(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAILP(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAIHP(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAVGPAR(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PISOP_EP(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PFWET(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAT(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSNM(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSN(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PMU0(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCARDI
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUMLEV(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVMLEV(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTMLEV(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PQMLEV(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCMLEV(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAPHMS(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGEOMLEV(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCPTGZLEV(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSST(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSKM1M(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PHLICE(:)   
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLICE(:)  
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLWML(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTHKICE(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSNTICE(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCHAR(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCHARHQ(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSRFL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSLRFL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PEMIS(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTICE(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSN(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWLMX(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUCURR(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVCURR(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PI10FGCV(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSDP2(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSDP3(:,:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSAM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWSAM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PFRTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PALBTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUSTRTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVSTRTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PAHFSTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PEVAPTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSKTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PANDAYVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PANFMVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0M(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0H(:) 

REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSSRFLTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PQSTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDQSTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCPTSTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCFHTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCFQTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCSATTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCAIRTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCPTSTIU(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCSATTIU(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCAIRTIU(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PRAQTI(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTSRF(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PLAMSK(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PKHLEV(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PKCLEV(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCFMLEV(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PKMFL(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PKHFL(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PKQFL(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PEVAPSNW(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PZ0MW(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PZ0HW(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PZ0QW(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBLENDPP(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCPTSPP(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PQSAPP(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBUOMPP(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PZDLPP(:)
! Tile depend
REAL(KIND=JPRB)   ,INTENT(OUT)    :: PZ0MTIW(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)    :: PZ0HTIW(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)    :: PZ0QTIW(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)    :: PZDLTI(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)    :: PQSAPPTI(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)    :: PCPTSPPTI(:,:)

REAL(KIND=JPRB)   ,INTENT(OUT)   :: PAN(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PAG(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PRD(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PRSOIL_STR(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PRECO(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCO2FLUX(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PCH4FLUX(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBVOCFLUX(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHVEGS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PEXDIAG(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHCO2S(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHBVOCS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTLS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTSS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTTS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTIS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRPLRG
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWETB(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWETL(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWETLU(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWETH(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWETHS(:)

LOGICAL           ,INTENT(IN)    :: LSICOUP
LOGICAL           ,INTENT(IN)    :: LDSICE(:)
LOGICAL           ,INTENT(IN)    :: LBLEND
!ifndef INTERFACE

TYPE(TSURF), POINTER :: YSURF
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SURFEXCDRIVER',0,ZHOOK_HANDLE)

YSURF => GET_SURF(YDSURF)

IF(UBOUND(KTVL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: KTVL TOO SHORT!')
ENDIF

IF(UBOUND(KCO2TYP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: KCO2TYP TOO SHORT!')
ENDIF

IF(UBOUND(KTVH,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: KTVH TOO SHORT!')
ENDIF

IF(UBOUND(PCVL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCVL TOO SHORT!')
ENDIF

IF(UBOUND(PCVH,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCVH TOO SHORT!')
ENDIF

IF(UBOUND(LDLAND,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: LDLAND TOO SHORT!')
ENDIF

IF(UBOUND(PCUR,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCUR TOO SHORT!')
ENDIF

IF(UBOUND(PLAIL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PLAIL TOO SHORT!')
ENDIF

IF(UBOUND(PLAIH,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PLAIH TOO SHORT!')
ENDIF

IF(UBOUND(PLAILP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PLAILP TOO SHORT!')
ENDIF

IF(UBOUND(PLAIHP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PLAIHP TOO SHORT!')
ENDIF

IF(UBOUND(PAVGPAR,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PAVGPAR TOO SHORT!')
ENDIF

IF(UBOUND(PISOP_EP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PISOP_EP TOO SHORT!')
ENDIF

IF(UBOUND(PSNM,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PSNM TOO SHORT!')
ENDIF

IF(UBOUND(PSNM,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PSNM LEVEL TOO SHORT!')
ENDIF

IF(UBOUND(PRSN,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PRSN TOO SHORT!')
ENDIF

IF(UBOUND(PRSN,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PRSN LEVEL TOO SHORT!')
ENDIF

IF(UBOUND(PMU0,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PMU0 TOO SHORT!')
ENDIF

IF(UBOUND(PUMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PUMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PVMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PVMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PTMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PTMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PQMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PQMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PCMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCMLEV TOO SHORT!')
ENDIF


IF(UBOUND(PAPHMS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PAPHMS TOO SHORT!')
ENDIF

IF(UBOUND(PGEOMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PGEOMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PCPTGZLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCPTGZLEV TOO SHORT!')
ENDIF

IF(UBOUND(PSST,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PSST TOO SHORT!')
ENDIF

IF(UBOUND(PTSKM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PTSKM1M TOO SHORT!')
ENDIF

IF(UBOUND(PCHAR,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCHAR TOO SHORT!')
ENDIF

IF(UBOUND(PCHARHQ,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCHARHQ TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PSSRFL TOO SHORT!')
ENDIF

IF(UBOUND(PSLRFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PSLRFL TOO SHORT!')
ENDIF

IF(UBOUND(PEMIS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PEMIS TOO SHORT!')
ENDIF

IF(UBOUND(PTICE,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PTICE TOO SHORT!')
ENDIF

IF(UBOUND(PTSN,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PTSN TOO SHORT!')
ENDIF

IF(UBOUND(PTSN,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PTSN KLEVSN TOO SHORT!')
ENDIF

IF(UBOUND(PWLMX,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PWLMX TOO SHORT!')
ENDIF

IF(UBOUND(PUCURR,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PUCURR TOO SHORT!')
ENDIF

IF(UBOUND(PVCURR,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PVCURR TOO SHORT!')
ENDIF

IF(UBOUND(PTSAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PTSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PTSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PWSAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PWSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PWSAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PWSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(KSOTY,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF KSOTY TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PALBTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PALBTI TOO SHORT!')
ENDIF

IF(UBOUND(PALBTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PALBTI TOO SHORT!')
ENDIF

IF(UBOUND(PUSTRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PUSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PUSTRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PUSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PVSTRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PVSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PVSTRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PVSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PTSKTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PTSKTI TOO SHORT!')
ENDIF

IF(UBOUND(PANDAYVT,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PANDAYVT TOO SHORT!')
ENDIF

IF(UBOUND(PANDAYVT,2) < KVTYPES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PANDAYVT TOO SHORT!')
ENDIF

IF(UBOUND(PANFMVT,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PANFMVT TOO SHORT!')
ENDIF

IF(UBOUND(PANFMVT,2) < KVTYPES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PANFMVT TOO SHORT!')
ENDIF

IF(UBOUND(PZ0M,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0M TOO SHORT!')
ENDIF

IF(UBOUND(PZ0H,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0H TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFLTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PSSRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFLTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PSSRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PQSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PQSTI TOO SHORT!')
ENDIF

IF(UBOUND(PQSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PQSTI TOO SHORT!')
ENDIF

IF(UBOUND(PDQSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDQSTI TOO SHORT!')
ENDIF

IF(UBOUND(PDQSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDQSTI TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCPTSTI TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCPTSTI TOO SHORT!')
ENDIF

IF(UBOUND(PCFHTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCFHTI TOO SHORT!')
ENDIF

IF(UBOUND(PCFHTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCFHTI TOO SHORT!')
ENDIF

IF(UBOUND(PCFQTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCFQTI TOO SHORT!')
ENDIF

IF(UBOUND(PCFQTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCFQTI TOO SHORT!')
ENDIF

IF(UBOUND(PCSATTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCSATTI TOO SHORT!')
ENDIF

IF(UBOUND(PCSATTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCSATTI TOO SHORT!')
ENDIF

IF(UBOUND(PCAIRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCAIRTI TOO SHORT!')
ENDIF

IF(UBOUND(PCAIRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCAIRTI TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSTIU,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCPTSTIU TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSTIU,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCPTSTIU TOO SHORT!')
ENDIF

IF(UBOUND(PCSATTIU,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCSATU TOO SHORT!')
ENDIF

IF(UBOUND(PCSATTIU,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCSATU TOO SHORT!')
ENDIF

IF(UBOUND(PCAIRTIU,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PCAIRU TOO SHORT!')
ENDIF

IF(UBOUND(PCAIRTIU,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PCAIRU TOO SHORT!')
ENDIF

IF(UBOUND(PRAQTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PRAQTI TOO SHORT!')
ENDIF

IF(UBOUND(PRAQTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PRAQTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSRF,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PTSRF TOO SHORT!')
ENDIF

IF(UBOUND(PTSRF,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PTSRF TOO SHORT!')
ENDIF

IF(UBOUND(PLAMSK,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PLAMSK TOO SHORT!')
ENDIF

IF(UBOUND(PLAMSK,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PLAMSK TOO SHORT!')
ENDIF

IF(UBOUND(PKHLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PKHLEV TOO SHORT!')
ENDIF

IF(UBOUND(PKCLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PKCLEV TOO SHORT!')
ENDIF

IF(UBOUND(PCFMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCFMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PKMFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PKMFL TOO SHORT!')
ENDIF

IF(UBOUND(PKHFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PKHFL TOO SHORT!')
ENDIF

IF(UBOUND(PKQFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PKQFL TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPSNW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PEVAPSNW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0MW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0HW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0QW TOO SHORT!')
ENDIF

IF(UBOUND(PBLENDPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PBLENDPP TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCPTSPP TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PQSAPP TOO SHORT!')
ENDIF

IF(UBOUND(PBUOMPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PBUOMPP TOO SHORT!')
ENDIF

IF(UBOUND(PZDLPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:  PZDLPPTOO SHORT!')
ENDIF

IF(UBOUND(PZ0MTIW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0MTIW TOO SHORT!')
ENDIF
IF(UBOUND(PZ0MTIW,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: SECOND DIM PZ0MTIW TOO SHORT!')
ENDIF
IF(UBOUND(PZ0HTIW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0HTIW TOO SHORT!')
ENDIF
IF(UBOUND(PZ0HTIW,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: SECOND DIM PZ0HTIW TOO SHORT!')
ENDIF
IF(UBOUND(PZ0QTIW,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZ0QTIW TOO SHORT!')
ENDIF
IF(UBOUND(PZ0QTIW,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: SECOND DIM PZ0QTIW TOO SHORT!')
ENDIF
IF(UBOUND(PZDLTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PZDLTI TOO SHORT!')
ENDIF
IF(UBOUND(PZDLTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: SECOND DIM PZDLTI TOO SHORT!')
ENDIF
IF(UBOUND(PQSAPPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PQSAPPTI TOO SHORT!')
ENDIF
IF(UBOUND(PQSAPPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: SECOND DIM PQSAPPTI TOO SHORT!')
ENDIF
IF(UBOUND(PCPTSPPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: PCPTSPPTI TOO SHORT!')
ENDIF
IF(UBOUND(PCPTSPPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER: SECOND DIM PCPTSPPTI TOO SHORT!')
ENDIF

IF(UBOUND(PDHTLS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHTLS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTLS,2) < KTILES) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHTLS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTLS,3) < KDHVTLS+KDHFTLS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHTLS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTSS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHTSS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTSS,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHTSS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTSS,3) < KDHVTSS+KDHFTSS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHTSS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTTS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHTTS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTTS,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHTTS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTTS,3) < KDHVTTS+KDHFTTS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHTTS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTIS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHTIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTIS,2) < KLEVI) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHTIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTIS,3) < KDHVTIS+KDHFTIS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHTIS TOO SHORT!')
ENDIF

IF(UBOUND(PHLICE,1) < KLON) THEN 
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PHLICE TOO SHORT!')
ENDIF
IF(UBOUND(PTLICE,1) < KLON) THEN 
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PTLICE TOO SHORT!')
ENDIF
IF(UBOUND(PTLWML,1) < KLON) THEN 
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PTLWML TOO SHORT!')
ENDIF

IF(UBOUND(PTHKICE,1) < KLON) THEN 
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PTHKICE TOO SHORT!')
ENDIF
IF(UBOUND(PSNTICE,1) < KLON) THEN 
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PSNTICE TOO SHORT!')
ENDIF

IF(UBOUND(LDSICE,1) < KLON) THEN 
  CALL ABORT_SURF('SURFEXCDRIVER:: DIMENSION OF LDSICE TOO SHORT!')
ENDIF

IF(UBOUND(PDHCO2S,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHCO2S TOO SHORT!')
ENDIF

IF(UBOUND(PDHCO2S,2) < 2) THEN !nb vegetation tiles
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHCO2S TOO SHORT!')
ENDIF

IF(UBOUND(PDHCO2S,3) < KDHVCO2S+KDHFCO2S) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHCO2S TOO SHORT!')
ENDIF

IF(UBOUND(PDHBVOCS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHBVOCS TOO SHORT!')
ENDIF

IF(UBOUND(PDHBVOCS,2) < 2) THEN !nb vegetation tiles
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHBVOCS TOO SHORT!')
ENDIF

IF(UBOUND(PDHBVOCS,3) < KDHVBVOCS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHBVOCS TOO SHORT!')
ENDIF

IF(UBOUND(PDHVEGS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PDHVEGS TOO SHORT!')
ENDIF

IF(UBOUND(PDHVEGS,2) < 2) THEN !nb vegetation tiles
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PDHVEGS TOO SHORT!')
ENDIF

IF(UBOUND(PDHVEGS,3) < KDHVVEGS+KDHFVEGS) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: THIRD DIMENSION OF PDHVEGS TOO SHORT!')
ENDIF

IF(UBOUND(PWETB,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PWETB TOO SHORT!')
ENDIF
IF(UBOUND(PWETL,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PWETL TOO SHORT!')
ENDIF
IF(UBOUND(PWETLU,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PWETLU TOO SHORT!')
ENDIF
IF(UBOUND(PWETH,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PWETH TOO SHORT!')
ENDIF
IF(UBOUND(PWETHS,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PWETHS TOO SHORT!')
ENDIF

IF(UBOUND(PEXDIAG,1) < KLON) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: FIRST DIMENSION OF PEXDIAG TOO SHORT!')
ENDIF

IF(UBOUND(PEXDIAG,2) < KDIAG) THEN
  CALL ABORT_SURF('SURFEXCDRIVER:: SECOND DIMENSION OF PEXDIAG TOO SHORT!')
ENDIF



!the diagnostics are not needed in SURFEXCDRIVER_CTL
!    *KDHVCO2S*     Number of variables for CO2
!    *KDHFCO2S*     Number of fluxes for CO2
!    *KDHVVEGS*     Number of variables for vegetation
!    *KDHFVEGS*     Number of fluxes for vegetation

CALL SURFEXCDRIVER_CTL(CDCONF &
 & , KIDIA, KFDIA, KLON, KLEVS, KTILES, KVTYPES, KDIAG, KSTEP &
 & , KLEVSN, KLEVI, LDLAND, KDHVTLS, KDHFTLS, KDHVTSS, KDHFTSS &
 & , KDHVTTS, KDHFTTS, KDHVTIS, KDHFTIS, K_VMASS &
 & , PTSTEP, PTSTEPF &
 & , PPPFD_TOA &
 & , KTVL, KCO2TYP, KTVH, PCVL, PCVH, PCUR & 
 & , PLAIL, PLAIH &
 & , PLAILP, PLAIHP, PAVGPAR, PISOP_EP &
 & , PFWET, PLAT &
 & , PSNM , PRSN &
 & , PMU0 , PCARDI &
 & , PUMLEV, PVMLEV, PTMLEV, PQMLEV, PCMLEV, PAPHMS, PGEOMLEV, PCPTGZLEV &
 & , PSST, PTSKM1M, PCHAR, PCHARHQ, PSSRFL, PSLRFL, PEMIS, PTICE, PTSN &
 & , PHLICE,PTLICE,PTLWML &   
 & , PTHKICE,PSNTICE &
 & , PWLMX, PUCURR, PVCURR, PI10FGCV  &
 & , PSSDP2, PSSDP3 &
 & , PTSAM1M, PWSAM1M, KSOTY &
 & , PFRTI, PALBTI &
 & , PUSTRTI, PVSTRTI, PAHFSTI, PEVAPTI, PTSKTI &
 & , PANDAYVT,PANFMVT &
 & , PZ0M, PZ0H &
 & , PSSRFLTI, PQSTI, PDQSTI, PCPTSTI, PCFHTI, PCFQTI, PCSATTI, PCAIRTI &
 & , PCPTSTIU, PCSATTIU, PCAIRTIU, PRAQTI, PTSRF, PLAMSK &
 & , PZ0MTIW, PZ0HTIW, PZ0QTIW, PZDLTI, PQSAPPTI, PCPTSPPTI &
 & , PKHLEV, PKCLEV, PCFMLEV, PKMFL, PKHFL, PKQFL, PEVAPSNW &
 & , PZ0MW, PZ0HW, PZ0QW, PBLENDPP, PCPTSPP, PQSAPP, PBUOMPP, PZDLPP &
 & , PAN,PAG,PRD,PRSOIL_STR,PRECO,PCO2FLUX,PCH4FLUX,PBVOCFLUX &
 & , PWETB, PWETL, PWETLU, PWETH, PWETHS &
 & , PDHTLS, PDHTSS, PDHTTS, PDHTIS &
 & , PDHVEGS, PEXDIAG, PDHCO2S, PDHBVOCS &
 & , PRPLRG &
 & , LSICOUP, LDSICE, LBLEND &
 & , YSURF%YCST, YSURF%YEXC, YSURF%YVEG, YSURF%YBVOC &
 & , YSURF%YAGS, YSURF%YAGF, YSURF%YSOIL, YSURF%YFLAKE, YSURF%YURB & 
 & )
IF (LHOOK) CALL DR_HOOK('SURFEXCDRIVER',1,ZHOOK_HANDLE)

!endif INTERFACE

!------------------------------------------------------------------------

END SUBROUTINE SURFEXCDRIVER
