SUBROUTINE SURFPPSAD( YDSURF,KIDIA,KFDIA,KLON,KTILES,LDPPCFLS &
 & , PTSTEP &
! input - trajectory
 & , PFRTI, PTSKTIP15, PAHFLTI5, PG0TI5   , PSTRTULEV5, PSTRTVLEV5, PTSKM1M5 &
 & , PUMLEV5, PVMLEV5, PQMLEV5 , PGEOMLEV5, PCPTSPP5  , PCPTGZLEV5 &
 & , PAPHMS5, PZ0MW5 , PZ0HW5  , PZ0QW5   , PQSAPP5   , PBUOM5 &
! input, tile dependent - trajectory
 & , PZ0MTIW5, PZ0HTIW5, PZ0QTIW5, PQSAPPTI5, PCPTSPPTI5, PBUOMTI5 &
! updated - trajectory
 & , PAHFSTI5, PEVAPTI5, PTSKE15 &
! output - trajectory
 & , PDIFTSLEV5, PDIFTQLEV5, PUSTRTI5, PVSTRTI5, PTSKTI5 &
 & , PU10M5    , PV10M5    , PT2M5   , PD2M5   , PQ2M5 &
 & , P10NU5    , P10NV5    &
! input
 & , PTSKTIP1, PAHFLTI, PG0TI , PSTRTULEV, PSTRTVLEV, PTSKM1M &
 & , PUMLEV  , PVMLEV , PQMLEV, PGEOMLEV , PCPTSPP  , PCPTGZLEV &
 & , PAPHMS  , PZ0MW  , PZ0HW , PZ0QW    , PQSAPP   , PBUOM &
 ! tile depend
 & , PZ0MTIW, PZ0HTIW, PZ0QTIW, PQSAPPTI, PCPTSPPTI, PBUOMTI &
! updated
 & , PAHFSTI , PEVAPTI, PTSKE1 &
! output
 & , PDIFTSLEV, PDIFTQLEV, PUSTRTI, PVSTRTI, PTSKTI &
 & , PU10M    , PV10M    , PT2M   , PD2M   , PQ2M &
 & , P10NU    , P10NV    &
 & )

USE PARKIND1, ONLY : JPIM, JPRB
USE ISO_C_BINDING

!ifndef INTERFACE

USE YOMHOOK,  ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOS_SURF, ONLY : TSURF, GET_SURF

USE ABORT_SURF_MOD
USE SURFPPSAD_CTL_MOD

!endif INTERFACE

! (C) Copyright 2005- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

!------------------------------------------------------------------------

!  PURPOSE:
!    Routine SURFPPSAD controls the computation of quantities at the end of
!    vertical diffusion, including routines to post-process weather elements.
!    (Adjoint)

!  SURFPPSAD is called by VDFMAINSAD

!  METHOD:
!    This routine is a shell needed by the surface library  externalisation.

!  AUTHOR:
!    M. Janiskova       ECMWF July 2005

!  REVISION HISTORY:

!  INTERFACE: 

!  INTERFACE: 

!    Integers (In):
!      KIDIA    :    Begin point in arrays
!      KFDIA    :    End point in arrays
!      KLON     :    Length of arrays
!      KTILES   :    Number of files


!    Reals (In):
!      PTSTEP    :  Timestep                                           s

!*      Reals (In):
!  Trajectory  Perturbation  Description                               Unit
!  PFRTI       ---           TILE FRACTIONS                            (0-1)
!                            1: WATER         5: SNOW ON LOW-VEG+BARE-SOIL
!                            2: ICE           6: DRY SNOW-FREE HIGH-VEG
!                            3: WET SKIN      7: SNOW UNDER HIGH-VEG
!                            4: DRY SNOW-FREE 8: BARE SOIL
!                               LOW-VEG
!  PTSKTIP15   PTSKTIP1      Tile skin temperature, t+1                K
!  PAHFLTI5    PAHFLTI       Surface latent heat flux                  Wm-2
!  PG0TI5      PG0TI         Surface ground heat flux                  W/m2
!  PSTRTULEV5  PSTRTULEV     TURBULENT FLUX OF U-MOMEMTUM             kg/(m*s2)
!  PSTRTVLEV5  PSTRTVLEV     TURBULENT FLUX OF V-MOMEMTUM             kg/(m*s2)
!  PTSKM1M5    PTSKM1M       Skin temperature, t                       K
!  PUMLEV5     PUMLEV        X-VELOCITY COMPONENT,                     m/s
!                            lowest atmospheric level
!  PVMLEV5     PVMLEV        Y-VELOCITY COMPONENT,                     m/s
!                            lowest atmospheric level
!  PQMLEV5     PQMLEV        SPECIFIC HUMIDITY                         kg/kg
!  PGEOMLEV5   PGEOMLEV      Geopotential, lowest atmospehric level    m2/s2
!  PCPTSPP5    PCPTSPP       Cp*Ts for post-processing of weather      J/kg
!                            parameters
!  PCPTGZLEV5  PCPTGZLEV     Geopotential, lowest atmospehric level    J/kg
!  PAPHMS5     PAPHMS        Surface pressure                           Pa
!  PZ0MW5      PZ0MW         Roughness length for momentum,WMO station  m
!  PZ0HW5      PZ0HW         Roughness length for heat, WMO station     m
!  PZ0QW5      PZ0QW         Roughness length for moisture,WMO station  m
!  PQSAPP5     PQSAPP        Apparent surface humidity                 kg/kg
!  PBUOM5      PBUOM         Buoyancy flux, for post-processing of     ????
!                            gustiness

!*      Reals (Updated):
!  Trajectory  Perturbation  Description                               Unit
!  PAHFSTI5    PAHFSTI       SURFACE SENSIBLE HEAT FLUX                W/m2
!  PEVAPTI5    PEVAPTI       SURFACE MOISTURE FLUX                     kg/m2/s
!  PTSKE15     PTSKE1        SKIN TEMPERATURE TENDENCY                 K/s

!*      Reals (Out):
!  Trajectory  Perturbation  Description                               Unit
!  PDIFTSLEV5  PDIFTSLEV     TURBULENT FLUX OF HEAT                    J/(m2*s)
!  PDIFTQLEV5  PDIFTQLEV     TURBULENT FLUX OF SPECIFIC HUMIDITY      kg/(m2*s)
!  PUSTRTI5    PUSTRTI       SURFACE U-STRESS                          N/m2 
!  PVSTRTI5    PVSTRTI       SURFACE V-STRESS                          N/m2
!  PTSKTI5     PTSKTI        SKIN TEMPERATURE                          K
!  PU10M5      PU10M         U-COMPONENT WIND AT 10 M                  m/s
!  PV10M5      PV10M         V-COMPONENT WIND AT 10 M                  m/s
!  P10NU5      P10NU         U-COMPONENT NEUTRAL WIND AT 10 M          m/s
!  P10NV5      P10NV         V-COMPONENT NEUTRAL WIND AT 10 M          m/s
!  PT2M5       PT2M          TEMPERATURE AT 2M                         K
!  PD2M5       PD2M          DEW POINT TEMPERATURE AT 2M               K
!  PQ2M5       PQ2M          SPECIFIC HUMIDITY AT 2M                   kg/kg


!     EXTERNALS.
!     ----------

!     ** SURFPPSAD_CTL CALLS SUCCESSIVELY:
!         *SPPCFLSAD*

!  DOCUMENTATION:
!    See Physics Volume of IFS documentation

!------------------------------------------------------------------------

IMPLICIT NONE

! Declaration of arguments

TYPE(C_PTR)       ,INTENT(IN)    :: YDSURF
INTEGER(KIND=JPIM),INTENT(IN)    :: KIDIA
INTEGER(KIND=JPIM),INTENT(IN)    :: KFDIA
INTEGER(KIND=JPIM),INTENT(IN)    :: KLON
INTEGER(KIND=JPIM),INTENT(IN)    :: KTILES
LOGICAL           ,INTENT(IN)    :: LDPPCFLS
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSTEP
REAL(KIND=JPRB)   ,INTENT(IN)    :: PFRTI(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSKTIP15(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAHFLTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PG0TI5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSTRTULEV5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSTRTVLEV5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSKM1M5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUMLEV5(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVMLEV5(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PQMLEV5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGEOMLEV5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCPTSPP5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCPTGZLEV5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAPHMS5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZ0MW5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZ0HW5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZ0QW5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PQSAPP5(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PBUOM5(:)
! Tile dependent pp
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZ0MTIW5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZ0HTIW5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZ0QTIW5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PQSAPPTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCPTSPPTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PBUOMTI5(:,:)

REAL(KIND=JPRB)   ,INTENT(INOUT) :: PAHFSTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PEVAPTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSKE15(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDIFTSLEV5(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDIFTQLEV5(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PUSTRTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PVSTRTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTSKTI5(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PU10M5(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PV10M5(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: P10NU5(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: P10NV5(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PT2M5(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PD2M5(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PQ2M5(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSKTIP1(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PAHFLTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PG0TI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSTRTULEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSTRTVLEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSKM1M(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUMLEV(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVMLEV(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PQMLEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGEOMLEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCPTSPP(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCPTGZLEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PAPHMS(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0MW(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0HW(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0QW(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PQSAPP(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBUOM(:)
! Tile dependent pp
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0MTIW(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0HTIW(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZ0QTIW(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PQSAPPTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCPTSPPTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBUOMTI(:,:)

REAL(KIND=JPRB)   ,INTENT(INOUT) :: PAHFSTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PEVAPTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSKE1(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PDIFTSLEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PDIFTQLEV(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUSTRTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVSTRTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSKTI(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PU10M(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PV10M(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: P10NU(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: P10NV(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PT2M(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PD2M(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PQ2M(:) 

! Local variables

TYPE(TSURF), POINTER :: YSURF
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

!ifndef INTERFACE

IF (LHOOK) CALL DR_HOOK('SURFPPSAD',0,ZHOOK_HANDLE)

YSURF => GET_SURF(YDSURF)

IF(UBOUND(PFRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTIP15,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PTSKTIP15 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTIP15,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PTSKTIP15 TOO SHORT!')
ENDIF

IF(UBOUND(PAHFLTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PAHFLTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PAHFLTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PAHFLTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PG0TI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PG0TI5 TOO SHORT!')
ENDIF

IF(UBOUND(PG0TI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PG0TI5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MTIW5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPS:: FIRST DIMENSION OF PZ0MTIW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MTIW5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPS:: SECOND DIMENSION OF PZ0MTIW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HTIW5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPS:: FIRST DIMENSION OF PZ0HTIW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HTIW5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPS:: SECOND DIMENSION OF PZ0HTIW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QTIW5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPS:: FIRST DIMENSION OF PZ0QTIW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QTIW5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPS:: SECOND DIMENSION OF PZ0QTIW5 TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPPTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPS:: FIRST DIMENSION OF PQSAPPTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPPTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPS:: SECOND DIMENSION OF PQSAPPTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPPTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPS:: FIRST DIMENSION OF PCPTSPPTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPPTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPS:: SECOND DIMENSION OF PCPTSPPTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PBUOMTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPS:: FIRST DIMENSION OF PBUOMTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PBUOMTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPS:: SECOND DIMENSION OF PBUOMTI5 TOO SHORT!')
ENDIF


IF(UBOUND(PSTRTULEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PSTRTULEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PSTRTVLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PSTRTVLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKM1M5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PTSKM1M5 TOO SHORT!')
ENDIF

IF(UBOUND(PUMLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PUMLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PVMLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PVMLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PQMLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PQMLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PGEOMLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PGEOMLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPP5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PCPTSPP5 TOO SHORT!')
ENDIF

IF(UBOUND(PCPTGZLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PCPTGZLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PAPHMS5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PAPHMS5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MW5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PZ0MW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HW5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PZ0HW5 TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QW5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PZ0QW5 TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPP5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PQSAPP5 TOO SHORT!')
ENDIF

IF(UBOUND(PBUOM5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PBUOM5 TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PAHFSTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PAHFSTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PEVAPTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PEVAPTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKE15,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PTSKE15 TOO SHORT!')
ENDIF

IF(UBOUND(PDIFTSLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PDIFTSLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PDIFTQLEV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PDIFTQLEV5 TOO SHORT!')
ENDIF

IF(UBOUND(PUSTRTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PUSTRTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PUSTRTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PUSTRTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PVSTRTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PVSTRTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PVSTRTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PVSTRTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTI5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PTSKTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTI5,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PTSKTI5 TOO SHORT!')
ENDIF

IF(UBOUND(PU10M5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PU10M5 TOO SHORT!')
ENDIF

IF(UBOUND(PV10M5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PV10M5 TOO SHORT!')
ENDIF

IF(UBOUND(P10NU5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: P10NU5 TOO SHORT!')
ENDIF

IF(UBOUND(P10NV5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: P10NV5 TOO SHORT!')
ENDIF

IF(UBOUND(PT2M5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PT2M5 TOO SHORT!')
ENDIF

IF(UBOUND(PD2M5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PD2M5 TOO SHORT!')
ENDIF

IF(UBOUND(PQ2M5,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PQ2M5 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTIP1,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PTSKTIP1 TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTIP1,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PTSKTIP1 TOO SHORT!')
ENDIF

IF(UBOUND(PAHFLTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PAHFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFLTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PAHFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PG0TI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PG0TI TOO SHORT!')
ENDIF

IF(UBOUND(PG0TI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PG0TI TOO SHORT!')
ENDIF

IF(UBOUND(PSTRTULEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PSTRTULEV TOO SHORT!')
ENDIF

IF(UBOUND(PSTRTVLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PSTRTVLEV TOO SHORT!')
ENDIF

IF(UBOUND(PTSKM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PTSKM1M TOO SHORT!')
ENDIF

IF(UBOUND(PUMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PUMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PVMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PVMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PQMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PQMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PGEOMLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PGEOMLEV TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PCPTSPP TOO SHORT!')
ENDIF

IF(UBOUND(PCPTGZLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PCPTGZLEV TOO SHORT!')
ENDIF

IF(UBOUND(PAPHMS,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PAPHMS TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MW,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PZ0MW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HW,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PZ0HW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QW,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PZ0QW TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPP,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PQSAPP TOO SHORT!')
ENDIF

IF(UBOUND(PBUOM,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PBUOM TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MTIW,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PZ0MTIW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0MTIW,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PZ0MTIW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HTIW,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PZ0HTIW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0HTIW,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PZ0HTIW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QTIW,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PZ0QTIW TOO SHORT!')
ENDIF

IF(UBOUND(PZ0QTIW,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PZ0QTIW TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PQSAPPTI TOO SHORT!')
ENDIF

IF(UBOUND(PQSAPPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PQSAPPTI TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PCPTSPPTI TOO SHORT!')
ENDIF

IF(UBOUND(PCPTSPPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PCPTSPPTI TOO SHORT!')
ENDIF

IF(UBOUND(PBUOMTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PBUOMTI TOO SHORT!')
ENDIF

IF(UBOUND(PBUOMTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PBUOMTI TOO SHORT!')
ENDIF


IF(UBOUND(PAHFSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSKE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PTSKE1 TOO SHORT!')
ENDIF

IF(UBOUND(PDIFTSLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PDIFTSLEV TOO SHORT!')
ENDIF

IF(UBOUND(PDIFTQLEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PDIFTQLEV TOO SHORT!')
ENDIF

IF(UBOUND(PUSTRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PUSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PUSTRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PUSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PVSTRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PVSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PVSTRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PVSTRTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD:: FIRST DIMENSION OF PTSKTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSKTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFPPSAD:: SECOND DIMENSION OF PTSKTI TOO SHORT!')
ENDIF

IF(UBOUND(PU10M,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PU10M TOO SHORT!')
ENDIF

IF(UBOUND(PV10M,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PV10M TOO SHORT!')
ENDIF

IF(UBOUND(P10NU,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: P10NU TOO SHORT!')
ENDIF

IF(UBOUND(P10NV,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: P10NV TOO SHORT!')
ENDIF

IF(UBOUND(PT2M,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PT2M TOO SHORT!')
ENDIF

IF(UBOUND(PD2M,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PD2M TOO SHORT!')
ENDIF

IF(UBOUND(PQ2M,1) < KLON) THEN
  CALL ABORT_SURF('SURFPPSAD: PQ2M TOO SHORT!')
ENDIF

CALL SURFPPSAD_CTL( KIDIA,KFDIA,KLON,KTILES,LDPPCFLS &
 & , PTSTEP &
! input - trajectory
 & , PFRTI, PTSKTIP15, PAHFLTI5, PG0TI5   , PSTRTULEV5, PSTRTVLEV5 , PTSKM1M5 &
 & , PUMLEV5, PVMLEV5, PQMLEV5 , PGEOMLEV5, PCPTSPP5  , PCPTGZLEV5 &
 & , PAPHMS5, PZ0MW5 , PZ0HW5  , PZ0QW5   , PQSAPP5   , PBUOM5  &
 & , YSURF%YCST, YSURF%YEXC &
! input, tile dependent - trajectory
 & , PZ0MTIW5, PZ0HTIW5, PZ0QTIW5, PQSAPPTI5, PCPTSPPTI5, PBUOMTI5 &
! updated -trajectory
 & , PAHFSTI5  , PEVAPTI5  , PTSKE15 &
! output - trajectory
 & , PDIFTSLEV5, PDIFTQLEV5, PUSTRTI5 , PVSTRTI5 , PTSKTI5 &
 & , PU10M5    , PV10M5    , PT2M5    , PD2M5    , PQ2M5   &
 & , P10NU5    , P10NV5    &
! input
 & , PTSKTIP1  , PAHFLTI   , PG0TI    , PSTRTULEV, PSTRTVLEV, PTSKM1M &
 & , PUMLEV    , PVMLEV    , PQMLEV   , PGEOMLEV , PCPTSPP  , PCPTGZLEV &
 & , PAPHMS    , PZ0MW     , PZ0HW    , PZ0QW    , PQSAPP   , PBUOM &
! input, tile dependent
 & , PZ0MTIW, PZ0HTIW, PZ0QTIW, PQSAPPTI, PCPTSPPTI, PBUOMTI &
! updated
 & , PAHFSTI   , PEVAPTI   , PTSKE1 &
! output
 & , PDIFTSLEV , PDIFTQLEV , PUSTRTI  , PVSTRTI  , PTSKTI &
 & , PU10M     , PV10M     , PT2M     , PD2M     , PQ2M &
 & , P10NU     , P10NV     &
 & )

IF (LHOOK) CALL DR_HOOK('SURFPPSAD',1,ZHOOK_HANDLE)

!endif INTERFACE

!------------------------------------------------------------------------

END SUBROUTINE SURFPPSAD
