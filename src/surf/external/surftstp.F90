SUBROUTINE SURFTSTP    (YDSURF, KIDIA , KFDIA , KLON  , KLEVS ,KCWS, KTILES,&
 & KLEVSN, KLEVO , KLEVI ,  KSTART , KSTEP,&
 & KDHVTSS , KDHFTSS,&
 & KDHVTTS , KDHFTTS,&
 & KDHVTIS , KDHFTIS,&
 & KDHVSSS , KDHFSSS,&
 & KDHVIIS , KDHFIIS,&
 & KDHVWLS , KDHFWLS,&
 & KDHVBIOS, KDHFBIOS, KDHVVEGS, KDHFVEGS,&                  !CTESSEL
 & KTVL , KTVH , KVEG , KSOTY,&
 & PSSDP2, PSSDP3, &
 & PTSPHY , PSDOR , PFRTI,&
 & PSST, PUSTRTI , PVSTRTI,&
 & PAHFSTI, PEVAPTI, PSSRFLTI, PSLRFLTI,&
 & PLAT , PANFMVT , PANDAYVT , PMU0,&                        !CTESSEL
 & PCVT, PLAIVT, PLAIL, PLAIH,&                              !CTESSEL
 & PCIL, &
 & PLAILC,  PLAIHC,&
 & LDLAND, LDSICE, LDLICE, LDSI, LDNH, LDOCN_KPP,&
 & PSNM1M  ,PTSNM1M,PASNM1M,PRSNM1M,PWSNM1M,&
 & PAPRS,  PTSKM1M ,PTSAM1M,PTIAM1M,&
 & PWLM1M  ,PWSAM1M,&
 & PTLICEM1M,PTLMNWM1M,PTLWMLM1M,PTLBOTM1M,PTLSFM1M,& 
 & PHLICEM1M,PHLMLM1M,PGEMU,PLDEPTH,LDLAKE,PCLAKE, &
 & PRSFC   ,PRSFL,& 
 & PSLRFL  ,PSSFC   ,PSSFL,& 
 & PCVL    ,PCVH    ,PCUR    ,PWLMX   ,PEVAPSNW,&
 & PUSRF   ,PVSRF   ,PTSRF,& 
 & PZO     ,PHO     ,PHO_INV ,PDO     ,POCDEPTH ,&
 & PUO0    ,PVO0    ,PUOC    ,PVOC    ,PTO0     ,&
 & PSO0    ,PADVT   ,PADVS   ,PTRI0   ,PTRI1    ,&
 & PSWDK_SAVE, PUSTRC ,PVSTRC,&
 & PUSTOKES,PVSTOKES,PTAUOCX ,PTAUOCY ,PPHIOC   ,&
 & PWSEMEAN,PWSFMEAN  ,&
 & LNEMOICETHK, PTHKICE, &
!-DIAGNOSTICS OUTPUT
 & PTSDFL  , PROFD , PROFS,&
 & PWFSD   , PMELT , PFWEV, PENES,&
 & PDIFM   , PDIFT , PDIFS, POTKE,&
 & PRESPBSTR,PRESPBSTR2,PBIOMASS_LAST,&                      !CTESSEL
 & PBIOMASSTR_LAST,PBIOMASSTR2_LAST,&                        !CTESSEL
 & PBLOSSVT, PBGAINVT, &                                     !CTESSEL
 & PLAI    , PBIOM , PBLOSS, PBGAIN, PBIOMSTR, PBIOMSTR2, &  !CTESSEL
!-TENDENCIES OUTPUT
 & PSNE1   , PTSNE1 , PASNE1,&
 & PRSNE1  , PWSNE1 , PTSAE1 , PTIAE1,&
 & PWLE1   , PWSAE1,&
 & PTLICEE1,PTLMNWE1,PTLWMLE1,&        
 & PTLBOTE1,PTLSFE1,PHLICEE1,PHLMLE1,&  
 & PUOE1   , PVOE1  , PTOE1  ,PSOE1,& 
 & PLAIE1  , PBSTRE1, PBSTR2E1,&                             !CTESSEL 
!-DDH OUTPUTS
 & PDHTSS  , PDHTTS , PDHTIS,&
 & PDHSSS  , PDHIIS , PDHWLS,&
 & PDHBIOS , PDHVEGS)                                        !CTESSEL

USE PARKIND1, ONLY : JPIM, JPRB
USE, INTRINSIC :: ISO_C_BINDING

!ifndef INTERFACE

USE YOMHOOK,  ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOS_SURF, ONLY : TSURF, GET_SURF

USE ABORT_SURF_MOD
USE SURFTSTP_CTL_MOD
!endif INTERFACE

! (C) Copyright 1993- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

!     ------------------------------------------------------------------
!**** *SURFTSTP* - UPDATES LAND VALUES OF TEMPERATURE, MOISTURE AND SNOW.

!     PURPOSE.
!     --------
!          This routine updates the sea ice values of temperature
!     and the land values of soil temperature, skin soil water,
!     moisture in soil layers (in M scaled to the first reservoir depth),
!     snow mass (in M water equivalent), snow temperature, snow density
!     and snow albedo. For temperature, this is done via a forward time
!     step damped with some implicit linear considerations: as if all
!     fluxes that explicitely depend on the variable had only a linear
!     variation around the t-1 value. For moisture: (a) the evaporation
!     of the interception layer is treated implicitely, via a
!     linearization, while the other sources are treated explicitely;
!     (b) The soil transfer is "fully semi-implicit" similar to vertical
!     diffusion. Lower boundary conditons are no heat flux and free
!     drainage.

!**   INTERFACE.
!     ----------
!          *SURFTSTP* IS CALLED FROM *CALLPAR*.
!          THE ROUTINE TAKES ITS INPUT FROM THE LONG-TERM STORAGE:
!     TSA,WL,WSA,SN AT T-1,TSK,SURFACE FLUXES COMPUTED IN OTHER PARTS OF
!     THE PHYSICS, AND W AND LAND-SEA MASK. IT RETURNS AS AN OUTPUT
!     TENDENCIES TO THE SAME VARIABLES (TSA,WL,WSA,SN).

!     PARAMETER   DESCRIPTION                                    UNITS
!     ---------   -----------                                    -----
!     INPUT PARAMETERS (INTEGER):
!    *KIDIA*      START POINT
!    *KFDIA*      END POINT
!    *KLEV*       NUMBER OF LEVELS
!    *KLON*       NUMBER OF GRID POINTS PER PACKET
!    *KLEVS*      NUMBER OF SOIL LAYERS
!    *KCWS        Number of layers to merge at the end for the soil water profile (for > 4layers)
!    *KTILES*     NUMBER OF TILES (I.E. SUBGRID AREAS WITH DIFFERENT 
!                 SURFACE BOUNDARY CONDITION)
!    *KTVL*       VEGETATION TYPE FOR LOW VEGETATION FRACTION
!    *KTVH*       VEGETATION TYPE FOR HIGH VEGETATION FRACTION
!    *KSOTY*      SOIL TYPE                                   (1-7)
!    *KLEVSN*     Number of snow layers  
!    *KLEVI*      Number of sea ice layers (diagnostics)
!    *KLEVO*      NUMBER OF LAYERS OF OCEAN MIXED LAYER MODEL       
!    *KSTART*     FIRST TIMESTEP                                    
!    *KSTEP*      CURRENT TIMESTEP                                  

!     INPUT PARAMETERS (REAL):
!    *PSICE*      .LT.0.5 FOR LATITUDE ROWS WITH NO SEA ICE POINTS
!    *PEPS*       COEFFICIENT FOR TIME FILTER
!    *PTSPHY*     TIME STEP FOR THE PHYSICS                      S
!    *PSDOR*      OROGRAPHIC PARAMETER                         (m)
!    *PFRTI*      TILE FRACTIONS                              (0-1)
!            1 : WATER                  5 : SNOW ON LOW-VEG+BARE-SOIL
!            2 : ICE                    6 : DRY SNOW-FREE HIGH-VEG
!            3 : WET SKIN               7 : SNOW UNDER HIGH-VEG
!            4 : DRY SNOW-FREE LOW-VEG  8 : BARE SOIL
!    *PCIL*         LAND-ICE FRACTION                          (0-1)
!    *PAHFSTI*    SURFACE SENSIBLE HEAT FLUX, FOR EACH TILE    W/M2
!    *PEVAPTI*    SURFACE MOISTURE FLUX, FOR EACH TILE         KG/M2/S
!    *PSSRFLTI*   NET SHORTWAVE RADIATION FLUX AT SURFACE, FOR
!                 EACH TILE                                    W/M2
!    *PSLRFLTI*   NET LONGWAVE  RADIATION AT THE SURFACE, FOR
!                 EACH TILE                                W/M**2
!    *PUO0*       HORIZONTAL VELOCITY OF OCEAN MIXED LAYER MODEL  
!    *PVO0*       HORIZONTAL VELOCITY OF OCEAN MIXED LAYER MODEL  
!    *PTO0*       TEMPERATURE OF OCEAN MIXED LAYER MODEL          
!    *PSO0*       SALINITY OF OCEAN MIXED LAYER MODEL             
!    *PADVT*      TEMPERATURE ADVECTION TERM FOR OCEAN MIXED LAYER MODEL 
!    *PADVS*      SALINITY ADVECTION TERM FOR OCEAN MIXED LAYER MODEL    
!    *PUSTOKES*   X-COMPONENT STOKES DRIFT
!    *PVSTOKES*   Y-COMPONENT STOKES DRIFT
!    *PTAUOCX*    SURFACE MOMENTUM FLUX TO OCEANS X-DIRECTION
!    *PTAUOCY*    SURFACE MOMENTUM FLUX TO OCEANS Y-DIRECTION
!    *PPHIOC*     ENERGY FLUX INTO OCEAN (DIMENSIONAL)                   
!    *PWSEMEAN*   WINDSEA VARIANCE
!    *PWSFMEAN*   WINDSEA MEAN FREQUENCY

!     INPUT PARAMETERS (LOGICAL):
!    *LDLAND*     LAND/SEA MASK (TRUE/FALSE)
!    *LDSICE*     SEA ICE MASK (.T. OVER SEA ICE)
!    *LDLICE*     LAND ICE MASK (.T. OVER LAND ICE)
!    *LDLAKE*     LAKE MASK (.T. OVER LAKE)
!    *LDSI*       TRUE IF THERMALLY RESPONSIVE SEA-ICE
!    *LDNH*       TRUE FOR NORTHERN HEMISPHERE LATITUDE ROW
!    *LDOCN_KPP*  TRUE IF OCEAN MIXED LAYER GRID                    
!    *PCLAKE*     REAL LAKE COVER 

!     INPUT PARAMETERS AT T-1 OR CONSTANT IN TIME (REAL):
!    *PSNM1M*     SNOW MASS (per unit area)                      kg/m**2
!    *PWSNM1M*    SNOW LIQUID WATER CONTENT (per unit area)      kg/m**2
!    *PTSAM1M*    SOIL TEMPERATURE                               K
!    *PTIAM1M*    SEA-ICE TEMPERATURE                            K
!          (NB: REPRESENTS THE FRACTION OF ICE ONLY, NOT THE GRID-BOX)
!    *PWLM1M*     SKIN RESERVOIR WATER CONTENT                   kg/m**2
!    *PWSAM1M*    SOIL MOISTURE                                m**3/m**3
!    *PTLICEM1M*  LAKE ICE TEMPERATURE                           K
!    *PTLMNWM1M*  LAKE MEAN WATER TEMPERATURE                    K
!    *PTLWMLM1M*  LAKE MIX-LAYER TEMPERATURE                     K
!    *PTLBOTM1M*  LAKE BOTTOM TEMPERATURE                        K
!    *PTLSFM1M*   LAKE SHAPE FACTOR (THERMOCLINE)                -
!    *PHLICEM1M*  LAKE ICE THICKNESS                             m
!    *PHLMLM1M*   LAKE MIX-LAYER THICKNESS                       m
!    *PGEMU*      SIN OF LATITUDE                                -
!    *PLDEPTH*    LAKE DEPTH                                     m
!    *PRSFC*      CONVECTIVE RAIN FLUX AT THE SURFACE          KG/M**2/S
!    *PRSFL*      LARGE SCALE RAIN FLUX AT THE SURFACE         KG/M**2/S
!    *PSLRFL*     NET LONGWAVE  RADIATION AT THE SURFACE         W/M**2
!    *PSSFC*      CONVECTIVE  SNOW FLUX AT THE SURFACE         KG/M**2/S
!    *PSSFL*      LARGE SCALE SNOW FLUX AT THE SURFACE         KG/M**2/S
!    *PCVL*       LOW VEGETATION COVER  (CORRECTED)              (0-1)
!    *PCVH*       HIGH VEGETATION COVER (CORRECTED)              (0-1)
!    *PCUR*       URBAN COVER (PASSIVE)                          (0-1)
!    *PWLMX*      MAXIMUM SKIN RESERVOIR CAPACITY                kg/m**2
!    *PEVAPSNW*   EVAPORATION FROM SNOW UNDER FOREST           KG/M**2/S
!    *POCDEPTH*     OCEAN DEPTH FOR OCEAN MIXED LAYER MODEL    (m)  
!    *PZO*          VERTICAL LAYER FOR OCEAN MIXED LAYER MODEL (m)  
!    *PDO*          VERTICAL LAYER FOR OCEAN MIXED LAYER MODEL (m)  
!    *PUSRF*      LOWEST LEVEL WIND U COMPONENT                   M/S
!    *PVSRF*      LOWEST LEVEL WIND V COMPONENT                   M/S
!    *PTSRF*      LOWEST LEVEL AIR TEMPERATURE                    K
!    *PAPRS*      LOWEST LEVEL AIR PRESSURE                       Pa
!    *POCDEPTH*     OCEAN DEPTH FOR OCEAN MIXED LAYER MODEL    (m)  
!    *PZO*          VERTICAL LAYER FOR OCEAN MIXED LAYER MODEL (m)  
!    *PDO*          VERTICAL LAYER FOR OCEAN MIXED LAYER MODEL (m)  
!     OUTPUT PARAMETERS (TENDENCIES):
!    *PSNE1*      SNOW MASS (per unit area) TENDENCY           kg/m**2/S
!    *PWSNE1*     SNOW LIQUD WATER CONTENT (per unit area) TENDENCY      kg/m**2/S
!    *PTSNE1*     SNOW TEMPERATURE                              K/S
!    *PASNE1*     SNOW ALBEDO                                   -/S
!    *PRSNE1*     SNOW DENSITY                                KG/M**3/S
!    *PTSAE1*     SOIL TEMPERATURE TENDENCY                     K/S
!    *PTIAE1*     SEA-ICE TEMPERATURE TENDENCY                  K/S
!          (NB: REPRESENTS THE FRACTION OF ICE ONLY, NOT THE GRID-BOX)
!    *PWLE1*      SKIN RESERVOIR WATER CONTENT TENDENCY       kg/m**2/s
!    *PWSAE1*     SOIL MOISTURE TENDENCY                   (m**3/m**3)/S
!    *PTLICEE1*   LAKE ICE TEMPERATURE TENDENCY                 K/S
!    *PTLMNWE1*   LAKE MEAN WATER TEMPERATURE TENDENCY          K/S
!    *PTLWMLE1*   LAKE MIX-LAYER TEMPERATURE TENDENCY           K/S
!    *PTLBOTE1*   LAKE BOTTOM TEMPERATURE TENDENCY              K/S
!    *PTLSFE1*    LAKE SHAPE FACTOR (THERMOCLINE) TENDENCY      -/S
!    *PHLICEE1*   LAKE ICE THICKNESS TENDENCY                   m/S
!    *PHLMLE1*    LAKE MIX-LAYER THICKNESS TENDENCY             m/S
!    *PWSAE1M*    SOIL MOISTURE TENDENCY                   (m**3/m**3)/S
!    *PUOE1*      VELOCITY TENDENCY OF OCEAN MIXED LAYER MODEL M/S**2
!    *PVOE1*      VELOCITY TENDENCY OF OCEAN MIXED LAYER MODEL M/S**2
!    *PTOE1*      TEMPERATURE TENDENCY OF OCEAN MIXED LAYER MODEL  K/S
!    *PSOE1*      SALINITY TENDENCY OF OCEAN MIXED LAYER MODEL  psu/S

!     OUTPUT PARAMETERS (DIAGNOSTIC):
!    *PTSDFL*     UPWARD FLUX BETWEEN SURFACE AND DEEP LAYER   W/M**2
!    *PROFD*      DEEP LAYER RUN-OFF                          kg/m**2/s
!    *PROFS*      SURFACE RUN-OFF                             kg/m**2/s
!    *PWFSD*      WATER FLUX BETWEEN LAYER 1 AND 2            kg/m**2/s
!    *PMELT*      WATER FLUX CORRESPONDING TO SNOW MELT       kg/m**2/s
!    *PFWEV*      EVAPORATION OVER LAND SURFACE               kg/m**2/s
!    *PENES*      SOIL ENERGY per unit area                   J/M**2
!    *PDHTSS*     Diagnostic array for snow T (see module yomcdh)
!    *PDHTTS*     Diagnostic array for soil T (see module yomcdh)
!    *PDHTIS*     Diagnostic array for ice T (see module yomcdh)
!    *PDHSSS*     Diagnostic array for snow mass (see module yomcdh)
!    *PDHIIS*     Diagnostic array for interception layer (see module yomcdh)
!    *PDHWLS*     Diagnostic array for soil water (see module yomcdh)
!    *PDIFM*      VISCOSITY OF OCEAN MIXED LAYER MODEL                
!    *PDIFT*      TEMPERATURE DIFFUSIVITY OF OCEAN MIXED LAYER MODEL  
!    *PDIFS*      SCALAR DIFFUSIVITY OF OCEAN MIXED LAYER MODEL       
!    *POTKE*      TURBULENT KINETIC ENERGY IN THE OCEAN MIXED LAYER   !OCEAN TKE


!     METHOD.
!     -------
!          STRAIGHTFORWARD ONCE THE DEFINITION OF THE CONSTANTS IS
!     UNDERSTOOD. FOR THIS REFER TO DOCUMENTATION. FOR THE TIME FILTER
!     SEE CORRESPONDING PART OF THE DOCUMENTATION OF THE ADIABATIC CODE.

!     EXTERNALS.
!     ----------
!          *SRFT*   COMPUTES THE TEMPERATURE CHANGES BEFORE THE SNOW
!                   MELTING.
!          *SRFWL*  COMPUTES THE SKIN RESERVOIR CHANGES.
!          *SRFWEXC*COMPUTES THE RUN-OFF AND SETS THE COEFFICIENTS OF
!                   THE TRIDIAGONAL MOISTURE SYSTEM OF EQUATIONS.
!          *SRFWDIF*SOLUTION OF THE TRIDIAGONAL MOISTURE SYSTEM OF EQUATIO
!          *SRFWINC*INCRMENTS OF SOIL MOSITURE, COMPUTATION OF DIAGNOSTICS
!          *SRFSN*  COMPUTES SNOW DEPTH CHANGES BEFORE SNOW MELTING.
!          *SRFSML* COMPUTES TEMPERATURE, SKIN RESERVOIR, SOIL WATER
!                   AND SNOW DEPTH CHANGES DUE TO SNOW MELTING.
!          *SRFWNG* CORRECTIONS TO AVOID NEGATIVE SOIL MOISTURE.

!     REFERENCE.
!     ----------
!          SEE SOIL PROCESSES' PART OF THE MODEL'S DOCUMENTATION FOR
!     DETAILS ABOUT THE MATHEMATICS OF THIS ROUTINE.
!     ------------------------------------------------------------------

!     P.VITERBO       E.C.M.W.F.     16/03/93.
!     MODIFIED BY
!     SURFACE TILES   P.VITERBO/ACMB          8/03/99.
!     Surface DDH for TILES P. Viterbo        17/05/2000.
!     J.F. Estrade *ECMWF* 03-10-01 move in surf vob
!     P. Viterbo   *ECMWF* 04-05-24 New argument PENES; change surface units
!     G. Balsamo   *ECMWF* 06-07-03 Add soil type and orographic var. (runoff)
!     V. Stepanenko        08-01-22 Stress components, sea surface temperature
!                                   are added as arguments
!     E. Dutra/G. Balsamo  08-05-01 Add lake tile
!     E. Dutra/G. Balsamo  08-06-08 Add revised snow
!     Y. Takaya    *ECMWF* 08-10-07 Implement an ocean mixed layer model
!     E. Dutra             09-11-16 snow 2009 cleaning 
!     E. Dutra             10/10/2014      net longwave tiled 
!     I. Ayan-Miguez       June 2023 Add object with spatially distributed parameters


IMPLICIT NONE

! Declaration of arguments

TYPE(C_PTR)       ,INTENT(IN)    :: YDSURF
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSDP2(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSDP3(:,:,:)
INTEGER(KIND=JPIM),INTENT(IN)    :: KIDIA 
INTEGER(KIND=JPIM),INTENT(IN)    :: KFDIA 
INTEGER(KIND=JPIM),INTENT(IN)    :: KLON 
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVS
INTEGER(KIND=JPIM),INTENT(IN)    :: KCWS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTART       
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTEP        
INTEGER(KIND=JPIM),INTENT(IN)    :: KTILES 
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVSN 
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVI 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTSS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTSS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTTS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTTS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVTIS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFTIS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVSSS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFSSS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVIIS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFIIS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVWLS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFWLS 
!CTESSEL specific
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVBIOS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFBIOS
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHVVEGS 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDHFVEGS
INTEGER(KIND=JPIM),INTENT(INOUT) :: KVEG(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAT(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCVT(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSKM1M(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAPRS(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAIVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAIL(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAIH(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCIL(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PANFMVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PANDAYVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRESPBSTR(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRESPBSTR2(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBIOMASS_LAST(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBIOMASSTR_LAST(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBIOMASSTR2_LAST(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBLOSSVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBGAINVT(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAIE1(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBSTRE1(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PBSTR2E1(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PLAI(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBIOM(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBLOSS(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBGAIN(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBIOMSTR(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PBIOMSTR2(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHBIOS(:,:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHVEGS(:,:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAILC(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAIHC(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PMU0(KLON)
!End CTESSEL specific
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEVO         
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSPHY 
INTEGER(KIND=JPIM),INTENT(IN)    :: KTVL(:) 
INTEGER(KIND=JPIM),INTENT(IN)    :: KTVH(:) 
INTEGER(KIND=JPIM),INTENT(IN)    :: KSOTY(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSDOR(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PFRTI(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUSTRTI(:,:)  
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVSTRTI(:,:)  
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAHFSTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PEVAPTI(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSRFLTI(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSLRFLTI(:,:)
LOGICAL           ,INTENT(IN)    :: LDLAND(:) 
LOGICAL           ,INTENT(IN)    :: LDSICE(:) 
LOGICAL           ,INTENT(IN)    :: LDLICE(:) 
LOGICAL           ,INTENT(IN)    :: LDSI 
LOGICAL           ,INTENT(IN)    :: LDNH(:) 
LOGICAL           ,INTENT(IN)    :: LDLAKE(:)  
LOGICAL           ,INTENT(IN)    :: LDOCN_KPP(:)  
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCLAKE(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSNM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSNM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PASNM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSNM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWSNM1M(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSAM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTIAM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWLM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWSAM1M(:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSFC(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSFL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSLRFL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSFC(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSSFL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCVL(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCVH(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PCUR(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWLMX(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PEVAPSNW(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUSRF(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVSRF(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTSRF(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTSDFL(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PROFD(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PROFS(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWFSD(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PMELT(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PFWEV(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PENES(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSNE1(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSNE1(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PASNE1(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRSNE1(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PWSNE1(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTSAE1(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTIAE1(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PWLE1(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PWSAE1(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTSS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTTS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHTIS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHSSS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDHIIS(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PDHWLS(:,:,:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSST(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLICEM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLMNWM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLWMLM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLBOTM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTLSFM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PHLICEM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PHLMLM1M(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGEMU(:) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLDEPTH(:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTLICEE1(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTLMNWE1(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTLWMLE1(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTLBOTE1(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTLSFE1(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PHLICEE1(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PHLMLE1(:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZO(:,:)     
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PHO(:,:)     
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PHO_INV(:,:) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PDO(:,:)     
REAL(KIND=JPRB)   ,INTENT(IN)    :: POCDEPTH(:)  
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PADVT(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PADVS(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUO0(:,:)    
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVO0(:,:)    
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUOC(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVOC(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUSTRC(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVSTRC(:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTO0(:,:)    
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSO0(:,:)    
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUOE1(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVOE1(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTOE1(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSOE1(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTRI0(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PTRI1(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSWDK_SAVE(:,:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDIFM(:,:)   
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDIFT(:,:)   
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDIFS(:,:)   
REAL(KIND=JPRB)   ,INTENT(INOUT) :: POTKE(:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUSTOKES(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVSTOKES(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTAUOCX(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTAUOCY(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PPHIOC(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWSEMEAN(:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWSFMEAN(:)
LOGICAL           ,INTENT(IN)    :: LNEMOICETHK
REAL(KIND=JPRB)   ,INTENT(IN)    :: PTHKICE(:)

!ifndef INTERFACE

TYPE(TSURF), POINTER :: YSURF
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SURFTSTP',0,ZHOOK_HANDLE)

YSURF => GET_SURF(YDSURF)

IF(UBOUND(KTVL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: KTVL TOO SHORT!')
ENDIF

IF(UBOUND(KTVH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: KTVH TOO SHORT!')
ENDIF

IF(UBOUND(KSOTY,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF KSOTY TOO SHORT!')
ENDIF

IF(UBOUND(PAPRS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PAPRS TOO SHORT!')
ENDIF

IF(UBOUND(PSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PSNM1M,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PSNM1M TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PTSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSNM1M,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PTSNM1M TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PASNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PASNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PRSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PRSNM1M,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PRSNM1M TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PWSNM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWSNM1M TOO SHORT!')
ENDIF

IF(UBOUND(PWSNM1M,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PWSNM1M TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PWLM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWLM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTLICEM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLICEM1M TOO SHORT!')
ENDIF
IF(UBOUND(PTLMNWM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLMNWM1M TOO SHORT!')
ENDIF
IF(UBOUND(PTLWMLM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLWMLM1M TOO SHORT!')
ENDIF
IF(UBOUND(PTLBOTM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLBOTM1M TOO SHORT!')
ENDIF
IF(UBOUND(PTLSFM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLSFM1M TOO SHORT!')
ENDIF
IF(UBOUND(PHLICEM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PHLICEM1M TOO SHORT!')
ENDIF
IF(UBOUND(PHLMLM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PHLMLM1M TOO SHORT!')
ENDIF
IF(UBOUND(PGEMU,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PGEMU TOO SHORT!')
ENDIF
IF(UBOUND(PLDEPTH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PLDEPTH TOO SHORT!')
ENDIF

IF(UBOUND(PRSFC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSFC TOO SHORT!')
ENDIF

IF(UBOUND(PRSFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSFL TOO SHORT!')
ENDIF

IF(UBOUND(PSLRFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSLRFL TOO SHORT!')
ENDIF

IF(UBOUND(PSSFC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSSFC TOO SHORT!')
ENDIF

IF(UBOUND(PSSFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSSFL TOO SHORT!')
ENDIF

IF(UBOUND(PCVL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCVL TOO SHORT!')
ENDIF

IF(UBOUND(PCVH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCVH TOO SHORT!')
ENDIF

IF(UBOUND(PCUR,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCUR TOO SHORT!')
ENDIF

IF(UBOUND(PWLMX,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWLMX TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPSNW,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PEVAPSNW TOO SHORT!')
ENDIF

IF(UBOUND(PUSRF,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PUSRF TOO SHORT!')
ENDIF

IF(UBOUND(PVSRF,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PVSRF TOO SHORT!')
ENDIF

IF(UBOUND(PTSRF,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTSFR TOO SHORT!')
ENDIF

IF(UBOUND(LDLAND,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDLAND TOO SHORT!')
ENDIF

IF(UBOUND(LDSICE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDSICE TOO SHORT!')
ENDIF

IF(UBOUND(LDLICE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDLICE TOO SHORT!')
ENDIF

IF(UBOUND(LDNH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDNH TOO SHORT!')
ENDIF

IF(UBOUND(PROFS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PROFS TOO SHORT!')
ENDIF

IF(UBOUND(PSNE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PSNE1 TOO SHORT!')
ENDIF

IF(UBOUND(PSNE1,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PSNE1 TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PTSNE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTSNE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTSNE1,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PTSNE1 TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PASNE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PASNE1 TOO SHORT!')
ENDIF

IF(UBOUND(PRSNE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PRSNE1 TOO SHORT!')
ENDIF

IF(UBOUND(PRSNE1,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PRSNE1 TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PWSNE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWSNE1 TOO SHORT!')
ENDIF

IF(UBOUND(PWSNE1,2) < KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: PWSNE1 TOO SHORT! LEVEL')
ENDIF

IF(UBOUND(PWLE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWLE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTLICEE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLICEE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTLMNWE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLMNWE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTLWMLE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLWMLE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTLBOTE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLBOTE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTLSFE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTLSFE1 TOO SHORT!')
ENDIF
IF(UBOUND(PHLICEE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PHLICEE1 TOO SHORT!')
ENDIF
IF(UBOUND(PHLMLE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PHLMLE1 TOO SHORT!')
ENDIF
IF(UBOUND(LDLAKE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: LDLAKE TOO SHORT!')
ENDIF
IF(UBOUND(PCLAKE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCLAKE TOO SHORT!')
ENDIF
IF(UBOUND(PTSDFL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTSDFL TOO SHORT!')
ENDIF

IF(UBOUND(PROFD,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PROFD TOO SHORT!')
ENDIF

IF(UBOUND(PWFSD,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWFSD TOO SHORT!')
ENDIF

IF(UBOUND(PMELT,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PMELT TOO SHORT!')
ENDIF

IF(UBOUND(PFWEV,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PFWEV TOO SHORT!')
ENDIF

IF(UBOUND(PENES,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PENES TOO SHORT!')
ENDIF

IF(UBOUND(PENES,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PENES TOO SHORT!')
ENDIF

IF(UBOUND(PSDOR,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSDOR TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PFRTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PFRTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PAHFSTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PAHFSTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PEVAPTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PEVAPTI TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFLTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSSRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PSSRFLTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PSSRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PSLRFLTI,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSLRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PSLRFLTI,2) < KTILES) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PSLRFLTI TOO SHORT!')
ENDIF

IF(UBOUND(PTSAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTIAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTIAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTIAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTIAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PWSAM1M,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PWSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTHKICE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTHKICE TOO SHORT!')
ENDIF

IF(UBOUND(PWSAM1M,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PWSAM1M TOO SHORT!')
ENDIF

IF(UBOUND(PTSAE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTSAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTSAE1,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTSAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTIAE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTIAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PTIAE1,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTIAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PWSAE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PWSAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PWSAE1,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PWSAE1 TOO SHORT!')
ENDIF

IF(UBOUND(PDHIIS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDHIIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHIIS,2) < KDHVIIS+KDHFIIS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDHIIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHWLS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDHWLS TOO SHORT!')
ENDIF

IF(UBOUND(PDHWLS,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDHWLS TOO SHORT!')
ENDIF

IF(UBOUND(PDHWLS,3) < KDHVWLS+KDHFWLS) THEN
  CALL ABORT_SURF('SURFTSTP: THIRD DIMENSION OF PDHWLS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTSS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDHTSS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTSS,2) > KLEVSN ) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDHTSS TOO BIG!')
ENDIF

IF(UBOUND(PDHTSS,3) < KDHVTSS+KDHFTSS) THEN
  CALL ABORT_SURF('SURFTSTP: THIRD DIMENSION OF PDHTSS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTTS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDHTTS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTTS,2) < KLEVS) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDHTTS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTTS,3) < KDHVTTS+KDHFTTS) THEN
  CALL ABORT_SURF('SURFTSTP: THIRD DIMENSION OF PDHTTS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTIS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDHTIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTIS,2) < KLEVI) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDHTIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHTIS,3) < KDHVTIS+KDHFTIS) THEN
  CALL ABORT_SURF('SURFTSTP: THIRD DIMENSION OF PDHTIS TOO SHORT!')
ENDIF

IF(UBOUND(PDHSSS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDHSSS TOO SHORT!')
ENDIF

IF(UBOUND(PDHSSS,2) > KLEVSN) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDHSSS TOO BIG!')
ENDIF

IF(UBOUND(PDHSSS,3) < KDHVSSS+KDHFSSS) THEN
  CALL ABORT_SURF('SURFTSTP: THIRD DIMENSION OF PDHSSS TOO SHORT!')
ENDIF


IF(UBOUND(PZO,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PZO TOO SHORT!')
ENDIF
IF(UBOUND(PZO,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PZO TOO SHORT!')
ENDIF
IF(UBOUND(PHO,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PHO TOO SHORT!')
ENDIF
IF(UBOUND(PHO,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PHO TOO SHORT!')
ENDIF
IF(UBOUND(PHO_INV,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PHO_INV TOO SHORT!')
ENDIF
IF(UBOUND(PHO_INV,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PHO_INV TOO SHORT!')
ENDIF
IF(UBOUND(PDO,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDO TOO SHORT!')
ENDIF
IF(UBOUND(PDO,2) < KLEVO) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDO TOO SHORT!')
ENDIF
IF(UBOUND(POCDEPTH,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF POCDEPTH TOO SHORT!')
ENDIF
IF(UBOUND(PADVT,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PADVT TOO SHORT!')
ENDIF
IF(UBOUND(PADVT,2) < KLEVO) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PADVT TOO SHORT!')
ENDIF
IF(UBOUND(PADVS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PADVS TOO SHORT!')
ENDIF
IF(UBOUND(PADVS,2) < KLEVO) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PADVS TOO SHORT!')
ENDIF
IF(UBOUND(PUO0,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PUO0 TOO SHORT!')
ENDIF
IF(UBOUND(PUO0,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PUO0 TOO SHORT!')
ENDIF
IF(UBOUND(PVO0,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PVO0 TOO SHORT!')
ENDIF
IF(UBOUND(PVO0,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PVO0 TOO SHORT!')
ENDIF
IF(UBOUND(PUOC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PUOC TOO SHORT!')
ENDIF
IF(UBOUND(PUOC,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PUOC TOO SHORT!')
ENDIF
IF(UBOUND(PVOC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PVOC TOO SHORT!')
ENDIF
IF(UBOUND(PVOC,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PVOC TOO SHORT!')
ENDIF
IF(UBOUND(PUSTRC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PUSTRC TOO SHORT!')
ENDIF
IF(UBOUND(PVSTRC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PVSTRC TOO SHORT!')
ENDIF
IF(UBOUND(PTO0,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTO0 TOO SHORT!')
ENDIF
IF(UBOUND(PTO0,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTO0 TOO SHORT!')
ENDIF
IF(UBOUND(PSO0,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSO0 TOO SHORT!')
ENDIF
IF(UBOUND(PSO0,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PSO0 TOO SHORT!')
ENDIF
IF(UBOUND(PUOE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PUOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PUOE1,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PUOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PVOE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PVOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PVOE1,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PVOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTOE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTOE1,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PSOE1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PSOE1,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PSOE1 TOO SHORT!')
ENDIF
IF(UBOUND(PTRI0,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTRI0 TOO SHORT!')
ENDIF
IF(UBOUND(PTRI0,2) < KLEVO) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTRI0 TOO SHORT!')
ENDIF
IF(UBOUND(PTRI1,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PTRI1 TOO SHORT!')
ENDIF
IF(UBOUND(PTRI1,2) < KLEVO) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PTRI1 TOO SHORT!')
ENDIF
IF(UBOUND(PSWDK_SAVE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PSWDK_SAVE TOO SHORT!')
ENDIF
IF(UBOUND(PSWDK_SAVE,2) < KLEVO) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PSWDK_SAVE TOO SHORT!')
ENDIF

IF(UBOUND(PDIFM,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDIFM TOO SHORT!')
ENDIF
IF(UBOUND(PDIFM,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDIFM TOO SHORT!')
ENDIF
IF(UBOUND(PDIFT,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDIFT TOO SHORT!')
ENDIF
IF(UBOUND(PDIFT,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDIFT TOO SHORT!')
ENDIF
IF(UBOUND(PDIFS,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF PDIFS TOO SHORT!')
ENDIF
IF(UBOUND(PDIFS,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF PDIFS TOO SHORT!')
ENDIF
IF(UBOUND(POTKE,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: FIRST DIMENSION OF POTKE TOO SHORT!')
ENDIF
IF(UBOUND(POTKE,2) < KLEVO+1) THEN
  CALL ABORT_SURF('SURFTSTP: SECOND DIMENSION OF POTKE TOO SHORT!')
ENDIF
IF(UBOUND(PUSTOKES,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PUSTOKES TOO SHORT!')
ENDIF
IF(UBOUND(PVSTOKES,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PVSTOKES TOO SHORT!')
ENDIF
IF(UBOUND(PTAUOCX,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTAUOCX TOO SHORT!')
ENDIF
IF(UBOUND(PTAUOCY,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PTAUOCY TOO SHORT!')
ENDIF
IF(UBOUND(PPHIOC,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PPHIOC TOO SHORT!')
ENDIF
IF(UBOUND(PWSEMEAN,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWSEMEAN TOO SHORT!')
ENDIF
IF(UBOUND(PCIL,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PCIL TOO SHORT!')
ENDIF
IF(UBOUND(PWSFMEAN,1) < KLON) THEN
  CALL ABORT_SURF('SURFTSTP: PWSFMEAN TOO SHORT!')
ENDIF

CALL SURFTSTP_CTL(KIDIA , KFDIA , KLON  , KLEVS , KCWS, KTILES,& 
 & KLEVSN ,KLEVO , KLEVI ,  KSTART , KSTEP,& 
 !
 !
 ! 
 ! this space is left for visual comparison to SURFTSTP.* and CALLPAR call
 ! The variables KLEVSN and KDH* are used in the external routine only
 ! The number of arguments per line is rearranged for readibility
 !
 ! 
 !
 & KTVL  , KTVH , KVEG ,KSOTY ,&
 & PTSPHY , PSDOR , PFRTI,&
 & PSST, PUSTRTI , PVSTRTI,&
 & PAHFSTI, PEVAPTI, PSSRFLTI,PSLRFLTI,&
 & PLAT,PANFMVT, PANDAYVT,PMU0,&                             !CTESSEL
 & PCVT, PLAIVT, PLAIL, PLAIH,&                              !CTESSEL
 & PCIL, &
 & PLAILC,  PLAIHC,&
 & LDLAND,  LDSICE,LDLICE, LDSI, LDNH, LDOCN_KPP,&
 & PSNM1M  ,PTSNM1M, PASNM1M, PRSNM1M,PWSNM1M,&
 & PAPRS   ,PTSKM1M ,PTSAM1M, PTIAM1M,&
 & PWLM1M  ,PWSAM1M,&
 & PTLICEM1M,PTLMNWM1M,PTLWMLM1M,PTLBOTM1M,PTLSFM1M,&
 & PHLICEM1M,PHLMLM1M,PGEMU,PLDEPTH,LDLAKE,PCLAKE, &
 & PRSFC   ,PRSFL,& 
 & PSLRFL  ,PSSFC   ,PSSFL,& 
 & PCVL    ,PCVH    ,PCUR    ,PWLMX   ,PEVAPSNW,&
 & PUSRF   ,PVSRF   ,PTSRF, &
 & PZO     ,PHO     ,PHO_INV ,PDO     ,POCDEPTH ,&
 & PUO0    ,PVO0    ,PUOC    ,PVOC    ,PTO0     ,&
 & PSO0    ,PADVT   ,PADVS   ,PTRI0   ,PTRI1    ,&
 & PSWDK_SAVE, PUSTRC ,PVSTRC, &
 & PUSTOKES,PVSTOKES,PTAUOCX ,PTAUOCY ,PPHIOC   ,&
 & PWSEMEAN,PWSFMEAN,&
 & PSSDP2, PSSDP3,&
 & YSURF%YCST   ,YSURF%YEXC   ,YSURF%YSOIL  ,YSURF%YVEG   ,&
 & YSURF%YFLAKE ,YSURF%YURB   ,YSURF%YAGS   ,YSURF%YMLM   ,YSURF%YOCEAN_ML,& 
 & LNEMOICETHK, PTHKICE,&
!-DIAGNOSTICS OUTPUT
 & PTSDFL  , PROFD , PROFS,&
 & PWFSD   , PMELT , PFWEV, PENES,&
 & PDIFM   , PDIFT , PDIFS, POTKE,&
 & PRESPBSTR,PRESPBSTR2,PBIOMASS_LAST,&                            !CTESSEL
 & PBIOMASSTR_LAST,PBIOMASSTR2_LAST,&                              !CTESSEL
 & PBLOSSVT, PBGAINVT,&                                            !CTESSEL
 & PLAI    , PBIOM , PBLOSS, PBGAIN, PBIOMSTR, PBIOMSTR2,&         !CTESSEL
!-TENDENCIES OUTPUT
 & PSNE1   , PTSNE1 , PASNE1,&
 & PRSNE1  , PWSNE1 , PTSAE1 , PTIAE1,&
 & PWLE1   , PWSAE1,&
 & PTLICEE1,PTLMNWE1,PTLWMLE1,& 
 & PTLBOTE1,PTLSFE1,PHLICEE1,PHLMLE1,&
 & PUOE1   ,PVOE1   ,PTOE1  ,PSOE1,&
 & PLAIE1  ,PBSTRE1 ,PBSTR2E1, &                                   !CTESSEL 
!-DDH OUTPUTS
 & PDHTSS  , PDHTTS , PDHTIS,&
 & PDHSSS  , PDHIIS , PDHWLS,&
 & PDHBIOS , PDHVEGS)                                              !CTESSEL


!-END OF CALL SURFTSTP

IF (LHOOK) CALL DR_HOOK('SURFTSTP',1,ZHOOK_HANDLE)

!endif INTERFACE

!     ------------------------------------------------------------------

END SUBROUTINE SURFTSTP
!
! 
! this space is left for visual comparison to SURFTSTP* and CALLPAR call
! The variables KLEVSN and KDH* are used in the external routine only
! The number of arguments per line is rearranged for readibility
!
!
!
!
!
!
!
!
!
!
!
!
!
