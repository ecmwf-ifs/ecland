SUBROUTINE RDRES(LOPLEFT)
USE PARKIND1  ,ONLY : JPIM     ,JPRB,  JPRD
USE YOMHOOK   ,ONLY : LHOOK    ,DR_HOOK, JPHOOK

#ifdef DOC
! (C) Copyright 2000- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

!**** *RDRES*   - Routine to read restart file

!     Purpose.
!     --------
!           Initialize model from restart file

!***  Interface.
!     ----------
!        *CALL* *RDRES

!     Explicit arguments :
!     --------------------
!         LOPLEFT: FLAG INDICATING WHETHER MORE POINTS NEED TO BE DONE

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!     Reference.
!     ----------

!     Author.
!     -------
!        Bart vd Hurk KNMI

!     Modifications.
!     --------------
!        Original : 2000-07-18

#endif

USE YOMLUN1S , ONLY : NULOUT
USE YOMCT01S , ONLY : NSTART, LNF
USE YOMGC1S  , ONLY : LMASK
USE YOMDYN1S , ONLY : TSTEP
USE YOMRIP   , ONLY : RTIMTR    ,RTIMST
USE YOMDPHY  , ONLY : NLON      ,NLAT     ,NTILES    ,NLALO ,NVHILO, NPOI, NPOIP, NPOIOFF,NPOIALL,NPOIPALL
USE YOMGPD1S , ONLY : VDIEWSSTL ,VDINSSSTL,VDISSHFTL,VDIETL    ,VDTSKTL, &
                    & VDANDAYVT,VDANFMVT, &
       & VDRESPBSTR,VDRESPBSTR2,VDBIOMASS_LAST

USE YOMLOG1S , ONLY : NDIMCDF
USE YOMDIM1S , ONLY : NPROMA
USE MPL_MODULE

IMPLICIT NONE
LOGICAL LOPLEFT    ! FLAG FOR RUNNING MORE GRID POINTS

!* Netcdf interface
INTEGER ISTART2(2),ICOUNT2(2)
INTEGER ISTART3(3),ICOUNT3(3)
INTEGER NCID,IERR,NVARID,NSTEPI,NVARTYP
INTEGER NDIMS(100),NVDIMS,NVATTS
INTEGER NDIM, NVARS, NGATTS, IRECDIM
CHARACTER*100 CNAME

REAL(KIND=JPRD), ALLOCATABLE :: ZINPUTT(:,:),ZINPUTV(:,:)

!* Local variables
INTEGER(KIND=JPIM) :: JTILE, JVT, IVAR
LOGICAL LOPRES

INTEGER(KIND=JPIM) :: MYPROC, NPROC
INTEGER(KIND=JPIM) :: ISTP, IENP
REAL(KIND=JPRD), ALLOCATABLE  :: ZBUF(:),RECV_BUF(:)
REAL(KIND=JPHOOK)    :: ZHOOK_HANDLE


#include "netcdf.inc"

IF (LHOOK) CALL DR_HOOK('RDRES',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK()
NPROC  = MPL_NPROC()

WRITE(NULOUT,*)'READING RESTART FILE'

!*         0.  Open surface climate field

NCID = NCOPN('restartin.nc', NCNOWRIT, IERR)
WRITE(NULOUT,*)'NETCDF-FILE restartin.nc OPENED ON UNIT ',NCID

!          0.5 Check dimensions and timing

CALL NCINQ(NCID, NDIM, NVARS, NGATTS, IRECDIM, IERR)


NVARID = NCVID(NCID, 'timestp', IERR)
CALL NCVGT1(NCID, NVARID, 1, NSTEPI, IERR)
IF(NSTEPI /= NSTART .AND. LNF )THEN
!IF(NSTEPI /= NSTART )THEN
  WRITE(NULOUT,*)'INITIAL STEP IN RESTART FILE INCORRECT: ',NSTART,NSTEPI
  CALL ABORT
ENDIF
NSTEPI=NSTART


RTIMTR=RTIMST+(REAL(NSTEPI,JPRD)+0.5_JPRD)*TSTEP


!*         1.  Read coordinates

CALL SUGC1S(NCID,LOPLEFT)

!*         1.  Read surface characteristics from NetCDF file(s)

CALL SUGPD1S(NCID)

!*         2.  Read surface prognostics

CALL SUGP1S(NCID)

!*         3.  Read tile fluxes, tile Z0, assimilation per vegtype and
!              accumulated quantities (for respiration calibration)

IF(NDIMCDF == 2)THEN
  ISTART2(1)=1
  ISTART2(2)=1
  ICOUNT2(1)=NLON
  ICOUNT2(2)=NLAT
ELSE
  ISTART2(1)=1
  ICOUNT2(1)=NLON
ENDIF


IF(NDIMCDF == 2)THEN
  ISTART3(1)=1
  ISTART3(2)=1
  ISTART3(3)=1
  ICOUNT3(1)=NLON
  ICOUNT3(2)=NLAT
  ICOUNT3(3)=NTILES
ELSE
  ISTART3(1)=1
  ISTART3(2)=1
  ICOUNT3(1)=NLON
  ICOUNT3(2)=NTILES
ENDIF
ALLOCATE (ZINPUTT(NLALO,NTILES))
ALLOCATE (ZBUF(NPOIALL))
ALLOCATE (RECV_BUF(NPOI))

ISTP  = NPOIOFF(MYPROC)+1
IENP  = NPOIOFF(MYPROC+1)


!     sensible heat flux
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Qh', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTT, IERR)
ENDIF
DO JTILE=1,NTILES
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTT(:,JTILE),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Qh")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDISSHFTL(:,JTILE,:),RECV_BUF)
ENDDO

!     latent heat flux
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Evap', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTT, IERR)
ENDIF
DO JTILE=1,NTILES
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTT(:,JTILE),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Evap")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDIETL(:,JTILE,:),RECV_BUF)
ENDDO

!     momentum flux u
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Momu', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTT, IERR)
ENDIF
DO JTILE=1,NTILES
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTT(:,JTILE),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Momu")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDIEWSSTL(:,JTILE,:),RECV_BUF)
ENDDO

!     momentum flux v
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Momv', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTT, IERR)
ENDIF
DO JTILE=1,NTILES
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTT(:,JTILE),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Momv")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDINSSSTL(:,JTILE,:),RECV_BUF)
ENDDO

!     skin temperature
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'SkinT', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTT, IERR)
ENDIF
DO JTILE=1,NTILES
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTT(:,JTILE),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:SkinT")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDTSKTL(:,JTILE,:),RECV_BUF)
ENDDO

IF(NDIMCDF == 2) THEN
  ISTART3(1)=1
  ISTART3(2)=1
  ISTART3(3)=1
  ICOUNT3(1)=NLON
  ICOUNT3(2)=NLAT
  ICOUNT3(3)=NVHILO
ELSE
  ISTART3(1)=1
  ISTART3(2)=1
  ICOUNT3(1)=NLON
  ICOUNT3(2)=NVHILO
ENDIF
DEALLOCATE (ZINPUTT)
ALLOCATE (ZINPUTV(NLALO,NVHILO))

!     daily net CO2 assimilation
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Anday', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTV, IERR)
ENDIF
DO JVT=1,NVHILO
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTV(:,JVT),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Anday")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDANDAYVT(:,JVT,:),RECV_BUF)
ENDDO

!     maximum leaf assimilation
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Anfm', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTV, IERR)
ENDIF
DO JVT=1,NVHILO
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTV(:,JVT),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Anfm")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDANFMVT(:,JVT,:),RECV_BUF)
ENDDO

!     respiration of above ground structural biomass
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Rstr', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTV, IERR)
ENDIF
DO JVT=1,NVHILO
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTV(:,JVT),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Rstr")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDRESPBSTR(:,JVT,:),RECV_BUF)
ENDDO

!     respiration of below ground structural biomass
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Rstr2', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTV, IERR)
ENDIF
DO JVT=1,NVHILO
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTV(:,JVT),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Rstr2")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDRESPBSTR2(:,JVT,:),RECV_BUF)
ENDDO

!     biomass of previous day
IF( MYPROC==1 ) THEN
  NVARID = NCVID(NCID, 'Blast', IERR)
  CALL NCVGT(NCID, NVARID, ISTART3, ICOUNT3, ZINPUTV, IERR)
ENDIF
DO JVT=1,NVHILO
  CALL MPL_SCATTERV(PRECVBUF=ZBUF(:),KROOT=1,PSENDBUF=ZINPUTV(:,JVT),KSENDCOUNTS=NPOIPALL(:),CDSTRING="RDRES:Blast")
  RECV_BUF=PACK(ZBUF(:),LMASK(ISTP:IENP))
  CALL UNPACK_BUFFER(VDBIOMASS_LAST(:,JVT,:),RECV_BUF)
ENDDO

!* -- close datafile
IF( MYPROC==1 ) THEN
  CALL NCCLOS(NCID,IERR)
ENDIF


DEALLOCATE (ZBUF)
DEALLOCATE (RECV_BUF)
DEALLOCATE (ZINPUTV)
CALL MPL_BARRIER()
IF (LHOOK) CALL DR_HOOK('RDRES',1,ZHOOK_HANDLE)

CONTAINS
  SUBROUTINE UNPACK_BUFFER(ARR, RECV_BUF)
    IMPLICIT NONE

    REAL(KIND=JPRB), INTENT(INOUT) :: ARR(:,:)
    REAL(KIND=JPRB), INTENT(IN) :: RECV_BUF(:)

    INTEGER(KIND=JPIM) :: IST,IEND,IBL,IPROMA

    !$OMP PARALLEL DO PRIVATE(IST,IEND,IBL,IPROMA)
    DO IST = 1, NPOI, NPROMA
      IEND = MIN(IST+NPROMA-1,NPOI)
      IBL = (IST-1)/NPROMA + 1
      IPROMA = IEND-IST+1

      ARR(1:IPROMA,IBL) = RECV_BUF(IST:IEND)
    ENDDO
    !$OMP END PARALLEL DO
  END SUBROUTINE UNPACK_BUFFER
END SUBROUTINE RDRES
